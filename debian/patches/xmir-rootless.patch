From 2cf1ea480b7ebcecc61509a54b27b685c4ccfc53 Mon Sep 17 00:00:00 2001
From: Robert Ancell <robert.ancell@canonical.com>
Date: Thu, 9 Jul 2015 14:03:49 +1200
Subject: [PATCH 2/4] xmir: Support rootless

Contributions from:
 Maarten Lankhorst <maarten.lankhorst@ubuntu.com>
 Robert Ancell <robert.ancell@canonical.com>
---
 composite/compalloc.c    |  6 ++++++
 composite/compositeext.h |  3 +++
 hw/xmir/xmir-cursor.c    |  5 ++++-
 hw/xmir/xmir-dri2.c      |  4 ++++
 hw/xmir/xmir-input.c     | 34 ++++++++++++++++++++++++++++++++++
 hw/xmir/xmir-output.c    |  8 ++++++++
 hw/xmir/xmir.c           | 48 +++++++++++++++++++++++++++++++++++++++---------
 hw/xmir/xmir.h           |  2 +-
 8 files changed, 99 insertions(+), 11 deletions(-)

diff --git a/composite/compalloc.c b/composite/compalloc.c
index 8daded0..fb1b476 100644
--- a/composite/compalloc.c
+++ b/composite/compalloc.c
@@ -46,6 +46,7 @@
 #endif
 
 #include "compint.h"
+#include "compositeext.h"
 
 static void
 compScreenUpdate(ScreenPtr pScreen)
@@ -411,6 +412,11 @@ compRedirectSubwindows(ClientPtr pClient, WindowPtr pWin, int update)
     return Success;
 }
 
+int CompositeRedirectSubwindows (WindowPtr pWin, int update)
+{
+    return compRedirectSubwindows (serverClient, pWin, update);
+}
+
 /*
  * Free one of the per-client per-subwindows resources,
  * which frees one redirect per subwindow
diff --git a/composite/compositeext.h b/composite/compositeext.h
index b96cb1d..f279013 100644
--- a/composite/compositeext.h
+++ b/composite/compositeext.h
@@ -35,6 +35,9 @@ extern _X_EXPORT Bool CompositeRegisterAlternateVisuals(ScreenPtr pScreen,
                                                         VisualID * vids,
                                                         int nVisuals);
 
+extern _X_EXPORT int CompositeRedirectSubwindows(WindowPtr pWin,
+						 int update);
+
 extern _X_EXPORT Bool CompositeRegisterImplicitRedirectionException(ScreenPtr pScreen,
                                                                     VisualID parentVisual,
                                                                     VisualID winVisual);
diff --git a/hw/xmir/xmir-cursor.c b/hw/xmir/xmir-cursor.c
index 459f9ac..c311d88 100644
--- a/hw/xmir/xmir-cursor.c
+++ b/hw/xmir/xmir-cursor.c
@@ -134,7 +134,10 @@ xmir_input_set_cursor(struct xmir_input *xmir_input)
     config = mir_cursor_configuration_from_buffer_stream(stream, cursor->bits->xhot, cursor->bits->yhot);
 
 apply:
-    mir_wait_for(mir_surface_configure_cursor(xmir_window_get(xmir_input->xmir_screen->screen->root)->surface, config));
+    if (!xmir_input->xmir_screen->rootless)
+        mir_wait_for(mir_surface_configure_cursor(xmir_window_get(xmir_input->xmir_screen->screen->root)->surface, config));
+    else if (xmir_input->focus_window)
+        mir_wait_for(mir_surface_configure_cursor(xmir_input->focus_window->surface, config));
     mir_cursor_configuration_destroy(config);
 
     if (stream)
diff --git a/hw/xmir/xmir-dri2.c b/hw/xmir/xmir-dri2.c
index 1f7c1b0..4f95006 100644
--- a/hw/xmir/xmir-dri2.c
+++ b/hw/xmir/xmir-dri2.c
@@ -90,8 +90,12 @@ static struct xmir_window *
 xmir_window_swappable_parent(WindowPtr win)
 {
     ScreenPtr screen = win->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
     PixmapPtr root, pixmap;
 
+    if (xmir_screen->rootless)
+        return NULL;
+
     root = screen->GetScreenPixmap(screen);
     pixmap = screen->GetWindowPixmap(win);
 
diff --git a/hw/xmir/xmir-input.c b/hw/xmir/xmir-input.c
index 855b6d3..4de3fe0 100644
--- a/hw/xmir/xmir-input.c
+++ b/hw/xmir/xmir-input.c
@@ -307,6 +307,37 @@ DDXRingBell(int volume, int pitch, int duration)
 {
 }
 
+static WindowPtr
+xmir_xy_to_window(ScreenPtr screen, SpritePtr sprite, int x, int y)
+{
+    struct xmir_input *xmir_input = NULL;
+    DeviceIntPtr device;
+
+    for (device = inputInfo.devices; device; device = device->next) {
+        if (device->deviceProc == xmir_pointer_proc &&
+            device->spriteInfo->sprite == sprite) {
+            xmir_input = device->public.devicePrivate;
+            break;
+        }
+    }
+
+    if (xmir_input == NULL) {
+        /* XTEST device */
+        sprite->spriteTraceGood = 1;
+        return sprite->spriteTrace[0];
+    }
+
+    if (xmir_input->focus_window) {
+        sprite->spriteTraceGood = 2;
+        sprite->spriteTrace[1] = xmir_input->focus_window->window;
+        return miSpriteTrace(sprite, x, y);
+    }
+    else {
+        sprite->spriteTraceGood = 1;
+        return sprite->spriteTrace[0];
+    }
+}
+
 static void
 fake_touch_move(struct xmir_input *xmir_input, struct xmir_window *xmir_window, int sx, int sy)
 {
@@ -476,6 +507,9 @@ InitInput(int argc, char *argv[])
     struct xmir_screen *xmir_screen = xmir_screen_get(pScreen);
     struct xmir_input *xmir_input;
 
+    if (xmir_screen->rootless)
+        pScreen->XYToWindow = xmir_xy_to_window;
+
     mieqInit();
 
     xmir_input = calloc(1, sizeof(*xmir_input));
diff --git a/hw/xmir/xmir-output.c b/hw/xmir/xmir-output.c
index f958e87..c1770d5 100644
--- a/hw/xmir/xmir-output.c
+++ b/hw/xmir/xmir-output.c
@@ -78,6 +78,9 @@ xmir_output_dpms(struct xmir_screen *xmir_screen, int mode)
     MirPowerMode mir_mode = mir_power_mode_on;
     Bool unchanged = TRUE;
 
+    if (xmir_screen->rootless)
+        return FALSE;
+
     switch (mode) {
     case DPMSModeOn:
         mir_mode = mir_power_mode_on;
@@ -306,6 +309,11 @@ xmir_output_handle_resize(struct xmir_window *xmir_window, int width, int height
         xmir_window->image = NULL;
     }
 
+    if (xmir_screen->rootless) {
+        screen->ResizeWindow(window, window->drawable.x, window->drawable.y, window_width, window_height, NULL);
+        return;
+    }
+
     if (!xmir_screen->windowed) {
         xmir_screen->windowed = 1;
 
diff --git a/hw/xmir/xmir.c b/hw/xmir/xmir.c
index 4afd66e..ef78cca 100644
--- a/hw/xmir/xmir.c
+++ b/hw/xmir/xmir.c
@@ -33,6 +33,7 @@
 #include <selection.h>
 #include <micmap.h>
 #include <misyncshm.h>
+#include <compositeext.h>
 #include <glx_extinit.h>
 
 #include <mir_toolkit/mir_surface.h>
@@ -91,6 +92,7 @@ ddxBeforeReset(void)
 void
 ddxUseMsg(void)
 {
+    ErrorF("-rootless              run rootless, requires wm support\n");
     ErrorF("-sw                    disable glamor rendering\n");
     ErrorF("-egl                   force use of EGL calls, disables DRI2 pass-through\n");
     ErrorF("-egl_sync              same as -egl, but with synchronous page flips.\n");
@@ -107,7 +109,8 @@ ddxProcessArgument(int argc, char *argv[], int i)
 {
     static int seen_shared;
 
-    if (strcmp(argv[i], "-sw") == 0 ||
+    if (strcmp(argv[i], "-rootless") == 0 ||
+        strcmp(argv[i], "-sw") == 0 ||
         strcmp(argv[i], "-egl") == 0 ||
         strcmp(argv[i], "-egl_sync") == 0 ||
         strcmp(argv[i], "-2x") == 0 ||
@@ -425,8 +428,21 @@ xmir_realize_window(WindowPtr window)
     xmir_screen->RealizeWindow = screen->RealizeWindow;
     screen->RealizeWindow = xmir_realize_window;
 
-    if (window->parent)
-        return ret;
+    if (xmir_screen->rootless) {
+        if (!window->parent) {
+            CompositeRedirectSubwindows(window, /*CompositeRedirectManual*/TRUE); // WTF? Where is this defined
+            RegionNull(&window->clipList);
+            RegionNull(&window->borderClip);
+            RegionNull(&window->winSize);
+        }
+
+        if (window->redirectDraw != RedirectDrawManual)
+            return ret;
+    }
+    else {
+        if (window->parent)
+            return ret;
+    }
 
     mir_connection_get_available_surface_formats (xmir_screen->conn, formats, 1024, &n_formats);
     for (i = 0; i < n_formats && pixel_format == mir_pixel_format_invalid; i++) {
@@ -546,8 +562,15 @@ xmir_handle_surface_event(struct xmir_window *xmir_window, MirSurfaceAttrib attr
 void
 xmir_close_surface(struct xmir_window *xmir_window)
 {
-    ErrorF("Root window closed, shutting down Xmir\n");
-    GiveUp(0);
+    WindowPtr window = xmir_window->window;
+    struct xmir_screen *xmir_screen = xmir_screen_get(window->drawable.pScreen);
+
+    if (!xmir_screen->rootless) {
+        ErrorF("Root window closed, shutting down Xmir\n");
+        GiveUp(0);
+    }
+
+    DeleteWindow(window, 1);
 }
 
 static void
@@ -679,7 +702,8 @@ xmir_is_unblank(int mode)
 Bool
 DPMSSupported(void)
 {
-    return TRUE;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screenInfo.screens[0]);
+    return !xmir_screen->rootless;
 }
 
 int
@@ -748,12 +772,16 @@ xmir_create_screen_resources(ScreenPtr screen)
     if (!ret)
         return ret;
 
-    screen->devPrivate = screen->CreatePixmap(screen, screen->width, screen->height, screen->rootDepth, CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    if (!xmir_screen->rootless)
+        screen->devPrivate = screen->CreatePixmap(screen, screen->width, screen->height, screen->rootDepth, CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    else
+        screen->devPrivate = fbCreatePixmap(screen, 0, 0, screen->rootDepth, 0);
+
     if (!screen->devPrivate)
         return FALSE;
 
 #ifdef GLAMOR_HAS_GBM
-    if (xmir_screen->glamor) {
+    if (xmir_screen->glamor && !xmir_screen->rootless) {
         glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(screen->devPrivate);
 
         glBindFramebuffer(GL_FRAMEBUFFER, pixmap_priv->base.fbo->fb);
@@ -835,7 +863,9 @@ xmir_screen_init(ScreenPtr pScreen, int argc, char **argv)
     xmir_screen->glamor = 1;
 
     for (i = 1; i < argc; i++) {
-        if (strcmp(argv[i], "-mir") == 0) {
+        if (strcmp(argv[i], "-rootless") == 0) {
+            xmir_screen->rootless = 1;
+        } else if (strcmp(argv[i], "-mir") == 0) {
             appid = argv[++i];
         } else if (strcmp(argv[i], "-mirSocket") == 0) {
             socket = argv[++i];
diff --git a/hw/xmir/xmir.h b/hw/xmir/xmir.h
index e43fa40..b67f3a1 100644
--- a/hw/xmir/xmir.h
+++ b/hw/xmir/xmir.h
@@ -53,7 +53,7 @@
 struct xmir_screen {
     ScreenPtr screen;
 
-    int depth, windowed, glamor, doubled;
+    int depth, rootless, windowed, glamor, doubled;
 
     CreateScreenResourcesProcPtr CreateScreenResources;
     CloseScreenProcPtr CloseScreen;
-- 
2.4.6

