d5e2f271ad93e50 xwayland: Remove two unused proc pointers.
ca17f3e9fd3b59f xwayland: Lock the pointer if it is confined and has no cursor
513e3bd3870fdb8 xwayland: Update root window size when desktop size changes
fafdb0cc9697eb5 xwayland: "Accept" confineTo on InputOnly windows
c217fcb4c4640ff xwayland: Allow pointer warp on root/None window

--- a/hw/xwayland/xwayland.c
+++ b/hw/xwayland/xwayland.c
@@ -177,11 +177,31 @@ xwl_cursor_warped_to(DeviceIntPtr device
     struct xwl_screen *xwl_screen = xwl_screen_get(screen);
     struct xwl_seat *xwl_seat = device->public.devicePrivate;
     struct xwl_window *xwl_window;
+    WindowPtr focus;
 
     if (!xwl_seat)
         xwl_seat = xwl_screen_get_default_seat(xwl_screen);
 
     xwl_window = xwl_window_from_window(window);
+    if (!xwl_window && xwl_seat->focus_window) {
+        focus = xwl_seat->focus_window->window;
+
+        /* Warps on non wl_surface backed Windows are only allowed
+         * as long as the pointer stays within the focus window.
+         */
+        if (x >= focus->drawable.x &&
+            y >= focus->drawable.y &&
+            x < focus->drawable.x + focus->drawable.width &&
+            y < focus->drawable.y + focus->drawable.height) {
+            if (!window) {
+                DebugF("Warp relative to pointer, assuming pointer focus\n");
+                xwl_window = xwl_seat->focus_window;
+            } else if (window == screen->root) {
+                DebugF("Warp on root window, assuming pointer focus\n");
+                xwl_window = xwl_seat->focus_window;
+            }
+        }
+    }
     if (!xwl_window)
         return;
 
@@ -206,6 +226,15 @@ xwl_cursor_confined_to(DeviceIntPtr devi
     }
 
     xwl_window = xwl_window_from_window(window);
+    if (!xwl_window && xwl_seat->focus_window) {
+        /* Allow confining on InputOnly windows, but only if the geometry
+         * is the same than the focus window.
+         */
+        if (window->drawable.class == InputOnly) {
+            DebugF("Confine on InputOnly window, assuming pointer focus\n");
+            xwl_window = xwl_seat->focus_window;
+        }
+    }
     if (!xwl_window)
         return;
 
@@ -307,9 +336,11 @@ xwl_realize_window(WindowPtr window)
     screen->RealizeWindow = xwl_realize_window;
 
     if (xwl_screen->rootless && !window->parent) {
+        BoxRec box = { 0, 0, xwl_screen->width, xwl_screen->height };
+
+        RegionReset(&window->winSize, &box);
         RegionNull(&window->clipList);
         RegionNull(&window->borderClip);
-        RegionNull(&window->winSize);
     }
 
     if (xwl_screen->rootless) {
--- a/hw/xwayland/xwayland-input.c
+++ b/hw/xwayland/xwayland-input.c
@@ -2645,11 +2645,35 @@ xwl_seat_emulate_pointer_warp(struct xwl
                                    x, y);
 }
 
+static Bool
+xwl_seat_maybe_lock_on_hidden_cursor(struct xwl_seat *xwl_seat)
+{
+    /* Some clients use hidden cursor+confineTo+relative motion
+     * to implement infinite panning (eg. 3D views), lock the
+     * pointer for so the relative pointer is used.
+     */
+    if (xwl_seat->x_cursor ||
+        !xwl_seat->cursor_confinement_window)
+        return FALSE;
+
+    if (xwl_seat->confined_pointer)
+        xwl_seat_destroy_confined_pointer(xwl_seat);
+
+    xwl_seat_create_pointer_warp_emulator(xwl_seat);
+    xwl_pointer_warp_emulator_lock(xwl_seat->pointer_warp_emulator);
+    return TRUE;
+}
+
 void
 xwl_seat_cursor_visibility_changed(struct xwl_seat *xwl_seat)
 {
-    if (xwl_seat->pointer_warp_emulator && xwl_seat->x_cursor != NULL)
+    if (xwl_seat->pointer_warp_emulator && xwl_seat->x_cursor != NULL) {
         xwl_seat_destroy_pointer_warp_emulator(xwl_seat);
+    } else if (!xwl_seat->x_cursor && xwl_seat->cursor_confinement_window) {
+        /* If the cursor goes hidden as is confined, lock it for
+         * relative motion to work. */
+        xwl_seat_maybe_lock_on_hidden_cursor(xwl_seat);
+    }
 }
 
 void
@@ -2688,6 +2712,9 @@ xwl_seat_confine_pointer(struct xwl_seat
     if (xwl_seat->pointer_warp_emulator)
         return;
 
+    if (xwl_seat_maybe_lock_on_hidden_cursor(xwl_seat))
+        return;
+
     xwl_seat->confined_pointer =
         zwp_pointer_constraints_v1_confine_pointer(pointer_constraints,
                                                    xwl_window->surface,
--- a/hw/xwayland/xwayland-output.c
+++ b/hw/xwayland/xwayland-output.c
@@ -187,8 +187,11 @@ update_screen_size(struct xwl_output *xw
     SetRootClip(xwl_screen->screen, xwl_screen->root_clip_mode);
 
     if (xwl_screen->screen->root) {
+        BoxRec box = { 0, 0, width, height };
+
         xwl_screen->screen->root->drawable.width = width;
         xwl_screen->screen->root->drawable.height = height;
+        RegionReset(&xwl_screen->screen->root->winSize, &box);
         RRScreenSizeNotify(xwl_screen->screen);
     }
 
--- a/hw/xwayland/xwayland.h
+++ b/hw/xwayland/xwayland.h
@@ -62,8 +62,6 @@ struct xwl_screen {
 
     CreateScreenResourcesProcPtr CreateScreenResources;
     CloseScreenProcPtr CloseScreen;
-    CreateWindowProcPtr CreateWindow;
-    DestroyWindowProcPtr DestroyWindow;
     RealizeWindowProcPtr RealizeWindow;
     UnrealizeWindowProcPtr UnrealizeWindow;
     XYToWindowProcPtr XYToWindow;
