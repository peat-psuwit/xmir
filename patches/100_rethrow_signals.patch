--- a/hw/dmx/dmxinit.c
+++ b/hw/dmx/dmxinit.c
@@ -834,7 +834,7 @@ static void dmxSetDefaultFontPath(char *
 /** This function is called in Xserver/os/utils.c from \a AbortServer().
  * We must ensure that backend and console state is restored in the
  * event the server shutdown wasn't clean. */
-void AbortDDX(void)
+void SigAbortDDX(int signo)
 {
     int i;
 
@@ -852,6 +852,11 @@ void ddxBeforeReset(void)
 }
 #endif
 
+void AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 /** This function is called in Xserver/dix/main.c from \a main() when
  * dispatchException & DE_TERMINATE (which is the only way to exit the
  * main loop without an interruption. */
--- a/hw/kdrive/src/kdrive.c
+++ b/hw/kdrive/src/kdrive.c
@@ -322,7 +322,7 @@ KdProcessSwitch (void)
 }
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
     KdDisableScreens ();
     if (kdOsFuncs)
@@ -339,6 +339,12 @@ AbortDDX(void)
 }
 
 void
+AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
+void
 ddxGiveUp (void)
 {
     AbortDDX ();
--- a/hw/vfb/InitOutput.c
+++ b/hw/vfb/InitOutput.c
@@ -214,11 +214,17 @@ ddxGiveUp(void)
 }
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
     ddxGiveUp();
 }
 
+void
+AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 #ifdef __APPLE__
 void
 DarwinHandleGUI(int argc, char *argv[])
--- a/hw/xfree86/common/xf86Events.c
+++ b/hw/xfree86/common/xf86Events.c
@@ -348,6 +348,8 @@ xf86InterceptSigIll(void (*sigillhandler
 int
 xf86SigWrapper(int signo)
 {
+  static Bool beenhere = FALSE;
+
   if ((signo == SIGILL) && xf86SigIllHandler) {
     (*xf86SigIllHandler)();
     return 0; /* continue */
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -1197,14 +1197,17 @@ OsVendorInit(void)
 }
 
 /*
- * ddxGiveUp --
+ * ddxSigGiveUp --
  *      Device dependent cleanup. Called by by dix before normal server death.
  *      For SYSV386 we must switch the terminal back to normal mode. No error-
  *      checking here, since there should be restored as much as possible.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than
+ *      calling abort().
  */
 
 void
-ddxGiveUp(void)
+ddxSigGiveUp(int signo)
 {
     int i;
 
@@ -1231,24 +1234,45 @@ ddxGiveUp(void)
     if (xorgHWOpenConsole)
 	xf86CloseConsole();
 
+    ErrorF (" ddxSigGiveUp: Closing log\n");
     xf86CloseLog();
 
     /* If an unexpected signal was caught, dump a core for debugging */
-    if (xf86Info.caughtSignal)
-	OsAbort();
+    if (xf86Info.caughtSignal) {
+        if (signo != 0) {
+            raise(signo);
+        } else {
+            OsAbort();
+        }
+    }
 }
 
+/*
+ * ddxGiveUp --
+ *      Device dependent cleanup. Called by by dix before normal server death.
+ *      For SYSV386 we must switch the terminal back to normal mode. No error-
+ *      checking here, since there should be restored as much as possible.
+ */
+
+void
+ddxGiveUp()
+{
+    ddxSigGiveUp(0);
+}
 
 
 /*
- * AbortDDX --
+ * SigAbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than calling
+ *      abort()
  */
 
 void
-AbortDDX(void)
+SigAbortDDX(int signo)
 {
   int i;
 
@@ -1281,7 +1305,20 @@ AbortDDX(void)
    * This is needed for an abnormal server exit, since the normal exit stuff
    * MUST also be performed (i.e. the vt must be left in a defined state)
    */
-  ddxGiveUp();
+  ddxSigGiveUp(signo);
+}
+
+/*
+ * AbortDDX --
+ *      DDX - specific abort routine.  The attempt is made to restore
+ *      all original setting of the displays. Also all devices are
+ *      closed.
+ */
+
+void
+AbortDDX()
+{
+    SigAbortDDX(0);
 }
 
 void
--- a/hw/xnest/Init.c
+++ b/hw/xnest/Init.c
@@ -117,12 +117,17 @@ CloseInput(void)
 /*
  * DDX - specific abort routine.  Called by AbortServer().
  */
-void AbortDDX(void)
+void SigAbortDDX(int signo)
 {
   xnestDoFullGeneration = True;
   xnestCloseDisplay();
 }
 
+void AbortDDX(void)
+{
+    SigAbortDDX(0);
+}
+
 /* Called by GiveUp(). */
 void ddxGiveUp(void)
 {
--- a/hw/xquartz/darwin.c
+++ b/hw/xquartz/darwin.c
@@ -765,17 +765,22 @@ void ddxGiveUp( void )
 
 
 /*
- * AbortDDX --
+ * [Sig]AbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
  */
-void AbortDDX( void )
+void SigAbortDDX( void )
 {
     ErrorF( "   AbortDDX\n" );
     OsAbort();
 }
 
+void AbortDDX( void )
+{
+    SigAbortDDX(0);
+}
+
 #include "mivalidate.h" // for union _Validate used by windowstr.h
 #include "windowstr.h"  // for struct _Window
 #include "scrnintstr.h" // for struct _Screen
--- a/hw/xwin/InitOutput.c
+++ b/hw/xwin/InitOutput.c
@@ -286,7 +286,7 @@ ddxGiveUp (void)
 
 /* See Porting Layer Definition - p. 57 */
 void
-AbortDDX (void)
+SigAbortDDX (int signo)
 {
 #if CYGDEBUG
   winDebug ("AbortDDX\n");
@@ -294,6 +294,12 @@ AbortDDX (void)
   ddxGiveUp ();
 }
 
+void
+AbortDDX (void)
+{
+    SigAbortDDX(0);
+}
+
 #ifdef __CYGWIN__
 /* hasmntopt is currently not implemented for cygwin */
 static const char *winCheckMntOpt(const struct mntent *mnt, const char *opt)
--- a/include/os.h
+++ b/include/os.h
@@ -440,7 +440,9 @@ typedef struct {
 /* stuff for FlushCallback */
 extern _X_EXPORT CallbackListPtr FlushCallback;
 
+extern _X_EXPORT void SigAbortDDX(int signo);
 extern _X_EXPORT void AbortDDX(void);
+extern _X_EXPORT void ddxSigGiveUp(int signo);
 extern _X_EXPORT void ddxGiveUp(void);
 extern _X_EXPORT int TimeSinceLastInputEvent(void);
 
--- a/os/log.c
+++ b/os/log.c
@@ -403,11 +403,12 @@ LogMessage(MessageType type, const char 
 }
 
 #ifdef __GNUC__
+void SigAbortServer(int signo) __attribute__((noreturn));
 void AbortServer(void) __attribute__((noreturn));
 #endif
 
 void
-AbortServer(void)
+SigAbortServer(int signo)
 {
 #ifdef XF86BIGFONT
     XF86BigfontCleanup();
@@ -415,11 +416,21 @@ AbortServer(void)
     CloseWellKnownConnections();
     OsCleanup(TRUE);
     CloseDownDevices();
-    AbortDDX();
+    SigAbortDDX(signo);
     fflush(stderr);
-    if (CoreDump)
-	OsAbort();
-    exit (1);
+    if (CoreDump) {
+        if (signo != 0)
+            raise(signo);
+        else
+            OsAbort();
+    } else
+       exit (1);
+}
+
+void
+AbortServer(void)
+{
+    SigAbortServer(0);
 }
 
 #define AUDIT_PREFIX "AUDIT: %s: %ld: "
@@ -522,6 +533,27 @@ VAuditF(const char *f, va_list args)
 }
 
 void
+FatalSignal(int signo)
+{
+    static Bool beenhere = FALSE;
+
+    if (beenhere)
+	ErrorF("\nFatalSignal re-entered, aborting\n");
+    else
+	ErrorF("\nCaught signal %d (%s). Server aborting\n",
+               signo, strsignal(signo));
+
+    if (!beenhere)
+	OsVendorFatalError();
+    if (!beenhere) {
+	beenhere = TRUE;
+	SigAbortServer(signo);
+    } else
+	abort();
+    /*NOTREACHED*/
+}
+
+void
 FatalError(const char *f, ...)
 {
     va_list args;
--- a/os/osinit.c
+++ b/os/osinit.c
@@ -148,13 +148,13 @@ OsSigHandler(int signo)
           case SIGBUS:
           case SIGILL:
           case SIGFPE:
+	      signal(signo,SIG_DFL);
 	      ErrorF("%s at address %p\n", strsignal(signo), sip->si_addr);
       }
   }
 #endif
 
-  FatalError("Caught signal %d (%s). Server aborting\n",
-	     signo, strsignal(signo));
+  FatalSignal(signo);
 }
 
 void
