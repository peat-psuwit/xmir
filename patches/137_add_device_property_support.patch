Index: xorg-server/Xi/Makefile.am
===================================================================
--- xorg-server.orig/Xi/Makefile.am	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/Xi/Makefile.am	2008-09-27 00:32:51.000000000 +0300
@@ -75,6 +75,8 @@
 	ungrdevb.c \
 	ungrdevb.h \
 	ungrdevk.c \
-	ungrdevk.h
+	ungrdevk.h \
+	xiproperty.c \
+	xiproperty.h
 
 EXTRA_DIST = stubs.c
Index: xorg-server/Xi/exglobals.h
===================================================================
--- xorg-server.orig/Xi/exglobals.h	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/Xi/exglobals.h	2008-09-27 00:32:51.000000000 +0300
@@ -50,6 +50,7 @@
 extern Mask DeviceButtonGrabMask;
 extern Mask DeviceButtonMotionMask;
 extern Mask DevicePresenceNotifyMask;
+extern Mask DevicePropertyNotifyMask;
 extern Mask PropagateMask[];
 
 extern int DeviceValuator;
@@ -68,6 +69,7 @@
 extern int DeviceMappingNotify;
 extern int ChangeDeviceNotify;
 extern int DevicePresenceNotify;
+extern int DevicePropertyNotify;
 
 extern int RT_INPUTCLIENT;
 
Index: xorg-server/Xi/extinit.c
===================================================================
--- xorg-server.orig/Xi/extinit.c	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/Xi/extinit.c	2008-09-27 00:32:51.000000000 +0300
@@ -109,6 +109,8 @@
 #include "ungrdev.h"
 #include "ungrdevb.h"
 #include "ungrdevk.h"
+#include "xiproperty.c"
+#include "xiproperty.h"
 
 static Mask lastExtEventMask = 1;
 int ExtEventIndex;
@@ -166,6 +168,7 @@
 Mask DeviceButtonGrabMask;
 Mask DeviceButtonMotionMask;
 Mask DevicePresenceNotifyMask;
+Mask DevicePropertyNotifyMask;
 
 int DeviceValuator;
 int DeviceKeyPress;
@@ -183,6 +186,7 @@
 int DeviceMappingNotify;
 int ChangeDeviceNotify;
 int DevicePresenceNotify;
+int DevicePropertyNotify;
 
 int RT_INPUTCLIENT;
 
@@ -288,6 +292,14 @@
 	return (ProcXGetDeviceControl(client));
     else if (stuff->data == X_ChangeDeviceControl)
 	return (ProcXChangeDeviceControl(client));
+    else if (stuff->data == X_ListDeviceProperties)
+        return (ProcXListDeviceProperties(client));
+    else if (stuff->data == X_ChangeDeviceProperty)
+        return ProcXChangeDeviceProperty(client);
+    else if (stuff->data == X_DeleteDeviceProperty)
+        return ProcXDeleteDeviceProperty(client);
+    else if (stuff->data == X_GetDeviceProperty)
+        return ProcXGetDeviceProperty(client);
 
     return (BadRequest);
 }
@@ -375,6 +387,14 @@
 	return (SProcXGetDeviceControl(client));
     else if (stuff->data == X_ChangeDeviceControl)
 	return (SProcXChangeDeviceControl(client));
+    else if (stuff->data == X_ListDeviceProperties)
+        return (SProcXListDeviceProperties(client));
+    else if (stuff->data == X_ChangeDeviceProperty)
+        return (SProcXChangeDeviceProperty(client));
+    else if (stuff->data == X_DeleteDeviceProperty)
+        return (SProcXDeleteDeviceProperty(client));
+    else if (stuff->data == X_GetDeviceProperty)
+        return (SProcXGetDeviceProperty(client));
 
     return (BadRequest);
 }
@@ -445,6 +465,10 @@
     else if (rep->RepType == X_ChangeDeviceControl)
 	SRepXChangeDeviceControl(client, len,
 				 (xChangeDeviceControlReply *) rep);
+    else if (rep->RepType == X_ListDeviceProperties)
+        SRepXListDeviceProperties(client, len, (xListDevicePropertiesReply*)rep);
+    else if (rep->RepType == X_GetDeviceProperty)
+         SRepXGetDeviceProperty(client, len, (xGetDevicePropertyReply *) rep);
     else {
 	FatalError("XINPUT confused sending swapped reply");
     }
@@ -550,6 +574,17 @@
     swaps(&to->control, n);
 }
 
+static void
+SDevicePropertyNotifyEvent (devicePropertyNotify *from, devicePropertyNotify *to)
+{
+    char n;
+
+    *to = *from;
+    swaps(&to->sequenceNumber,n);
+    swapl(&to->time, n);
+    swapl(&to->atom, n);
+}
+
 /**************************************************************************
  *
  * Allow the specified event to have its propagation suppressed.
@@ -670,6 +705,7 @@
     DeviceKeyStateNotify = ChangeDeviceNotify + 1;
     DeviceButtonStateNotify = DeviceKeyStateNotify + 1;
     DevicePresenceNotify = DeviceButtonStateNotify + 1;
+    DevicePropertyNotify = DevicePresenceNotify + 1;
 
     event_base[KeyClass] = DeviceKeyPress;
     event_base[ButtonClass] = DeviceButtonPress;
@@ -745,6 +781,10 @@
 
     DevicePresenceNotifyMask = GetNextExtEventMask();
     SetEventInfo(DevicePresenceNotifyMask, _devicePresence);
+
+    DevicePropertyNotifyMask = GetNextExtEventMask();
+    SetMaskForExtEvent(DevicePropertyNotifyMask, DevicePropertyNotify);
+
     SetEventInfo(0, _noExtensionEvent);
 }
 
@@ -786,6 +826,7 @@
     DeviceKeyStateNotify = 13;
     DeviceButtonStateNotify = 13;
     DevicePresenceNotify = 14;
+    DevicePropertyNotify = 15;
 
     BadDevice = 0;
     BadEvent = 1;
@@ -824,6 +865,7 @@
     EventSwapVector[DeviceMappingNotify] = NotImplemented;
     EventSwapVector[ChangeDeviceNotify] = NotImplemented;
     EventSwapVector[DevicePresenceNotify] = NotImplemented;
+    EventSwapVector[DevicePropertyNotify] = NotImplemented;
     RestoreExtensionEvents();
 }
 
@@ -909,6 +951,8 @@
 	DO_SWAP(SChangeDeviceNotifyEvent, changeDeviceNotify);
     else if (type == DevicePresenceNotify)
 	DO_SWAP(SDevicePresenceNotifyEvent, devicePresenceNotify);
+    else if (type == DevicePropertyNotify)
+	DO_SWAP(SDevicePropertyNotifyEvent, devicePropertyNotify);
     else {
 	FatalError("XInputExtension: Impossible event!\n");
     }
@@ -936,6 +980,7 @@
 	IReqCode = extEntry->base;
 	AllExtensionVersions[IReqCode - 128] = thisversion;
 	MakeDeviceTypeAtoms();
+	XIInitKnownProperties();
 	RT_INPUTCLIENT = CreateNewResourceType((DeleteType) InputClientGone);
 	RegisterResourceName(RT_INPUTCLIENT, "INPUTCLIENT");
 	FixExtensionEvents(extEntry);
Index: xorg-server/Xi/xiproperty.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/Xi/xiproperty.c	2008-09-27 00:36:39.000000000 +0300
@@ -0,0 +1,772 @@
+/*
+ * Copyright © 2006 Keith Packard
+ * Copyright © 2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WAXIANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WAXIANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/* This code is a modified version of randr/rrproperty.c */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "dix.h"
+#include "inputstr.h"
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XIproto.h>
+#include "exglobals.h"
+#include "exevents.h"
+#include "swaprep.h"
+
+#include "xiproperty.h"
+#include "xserver-properties.h"
+
+/**
+ * Properties used or alloced from inside the server.
+ */
+static struct dev_properties
+{
+    Atom type;
+    char *name;
+} dev_properties[] = {
+    {0, XI_PROP_ENABLED}
+};
+
+static long XIPropHandlerID = 1;
+
+/**
+ * Return the type assigned to the specified atom or 0 if the atom isn't known
+ * to the DIX.
+ */
+_X_EXPORT Atom
+XIGetKnownProperty(char *name)
+{
+    int i;
+    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
+    {
+        if (strcmp(name, dev_properties[i].name) == 0)
+            return dev_properties[i].type;
+    }
+
+    return 0;
+}
+
+/**
+ * Init those properties that are allocated by the server and most likely used
+ * by the DIX or the DDX.
+ */
+void
+XIInitKnownProperties(void)
+{
+    int i;
+    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
+    {
+        dev_properties[i].type =
+            MakeAtom(dev_properties[i].name,
+                     strlen(dev_properties[i].name),
+                     TRUE);
+    }
+}
+
+
+/* Registers a new property handler on the given device and returns a unique
+ * identifier for this handler. This identifier is required to unregister the
+ * property handler again.
+ * @return The handler's identifier or 0 if an error occured.
+ */
+long
+XIRegisterPropertyHandler(DeviceIntPtr         dev,
+                          int (*SetProperty) (DeviceIntPtr dev,
+                                               Atom property,
+                                               XIPropertyValuePtr prop),
+                          int (*GetProperty) (DeviceIntPtr dev,
+                                               Atom property),
+                          int (*DeleteProperty) (DeviceIntPtr dev,
+                                                 Atom property))
+{
+    XIPropertyHandlerPtr new_handler;
+
+    new_handler = xcalloc(1, sizeof(XIPropertyHandler));
+    if (!new_handler)
+        return 0;
+
+    new_handler->id = XIPropHandlerID++;
+    new_handler->SetProperty = SetProperty;
+    new_handler->GetProperty = GetProperty;
+    new_handler->DeleteProperty = DeleteProperty;
+    new_handler->next = dev->properties.handlers;
+    dev->properties.handlers = new_handler;
+
+    return new_handler->id;
+}
+
+void
+XIUnRegisterPropertyHandler(DeviceIntPtr dev, long id)
+{
+    XIPropertyHandlerPtr curr, prev = NULL;
+
+    curr = dev->properties.handlers;
+    while(curr && curr->id != id)
+    {
+        prev = curr;
+        curr = curr->next;
+    }
+
+    if (!curr)
+        return;
+
+    if (!prev) /* first one */
+        dev->properties.handlers = curr->next;
+    else
+        prev->next = curr->next;
+
+    xfree(curr);
+}
+
+static XIPropertyPtr
+XICreateDeviceProperty (Atom property)
+{
+    XIPropertyPtr   prop;
+
+    prop = (XIPropertyPtr)xalloc(sizeof(XIPropertyRec));
+    if (!prop)
+        return NULL;
+
+    prop->next         = NULL;
+    prop->propertyName = property;
+    prop->value.type   = None;
+    prop->value.format = 0;
+    prop->value.size   = 0;
+    prop->value.data   = NULL;
+    prop->deletable    = TRUE;
+
+    return prop;
+}
+
+static XIPropertyPtr
+XIFetchDeviceProperty(DeviceIntPtr dev, Atom property)
+{
+    XIPropertyPtr   prop;
+
+    for (prop = dev->properties.properties; prop; prop = prop->next)
+        if (prop->propertyName == property)
+            return prop;
+    return NULL;
+}
+
+static void
+XIDestroyDeviceProperty (XIPropertyPtr prop)
+{
+    if (prop->value.data)
+        xfree(prop->value.data);
+    xfree(prop);
+}
+
+/* This function destroys all of the device's property-related stuff,
+ * including removing all device handlers.
+ * DO NOT CALL FROM THE DRIVER.
+ */
+void
+XIDeleteAllDeviceProperties (DeviceIntPtr device)
+{
+    XIPropertyPtr               prop, next;
+    XIPropertyHandlerPtr        curr_handler, next_handler;
+    devicePropertyNotify        event;
+
+    for (prop = device->properties.properties; prop; prop = next)
+    {
+        next = prop->next;
+
+        event.type      = DevicePropertyNotify;
+        event.deviceid  = device->id;
+        event.state     = PropertyDelete;
+        event.atom      = prop->propertyName;
+        event.time      = currentTime.milliseconds;
+        SendEventToAllWindows(device, DevicePropertyNotifyMask,
+                (xEvent*)&event, 1);
+
+        XIDestroyDeviceProperty(prop);
+    }
+
+    /* Now free all handlers */
+    curr_handler = device->properties.handlers;
+    while(curr_handler)
+    {
+        next_handler = curr_handler->next;
+        xfree(curr_handler);
+        curr_handler = next_handler;
+    }
+}
+
+
+int
+XIDeleteDeviceProperty (DeviceIntPtr device, Atom property, Bool fromClient)
+{
+    XIPropertyPtr               prop, *prev;
+    devicePropertyNotify        event;
+    int                         rc = Success;
+
+    for (prev = &device->properties.properties; (prop = *prev); prev = &(prop->next))
+        if (prop->propertyName == property)
+            break;
+
+    if (fromClient && !prop->deletable)
+        return BadAccess;
+
+    /* Ask handlers if we may delete the property */
+    if (device->properties.handlers)
+    {
+        XIPropertyHandlerPtr handler = device->properties.handlers;
+        while(handler)
+        {
+            if (handler->DeleteProperty)
+                rc = handler->DeleteProperty(device, prop->propertyName);
+            if (rc != Success)
+                return (rc);
+            handler = handler->next;
+        }
+    }
+
+    if (prop)
+    {
+        *prev = prop->next;
+        event.type      = DevicePropertyNotify;
+        event.deviceid  = device->id;
+        event.state     = PropertyDelete;
+        event.atom      = prop->propertyName;
+        event.time      = currentTime.milliseconds;
+        SendEventToAllWindows(device, DevicePropertyNotifyMask,
+                              (xEvent*)&event, 1);
+        XIDestroyDeviceProperty (prop);
+    }
+
+    return Success;
+}
+
+int
+XIChangeDeviceProperty (DeviceIntPtr dev, Atom property, Atom type,
+                        int format, int mode, unsigned long len,
+                        pointer value, Bool sendevent)
+{
+    XIPropertyPtr               prop;
+    devicePropertyNotify        event;
+    int                         size_in_bytes;
+    int                         total_size;
+    unsigned long               total_len;
+    XIPropertyValuePtr          prop_value;
+    XIPropertyValueRec          new_value;
+    Bool                        add = FALSE;
+    int                         rc;
+
+    size_in_bytes = format >> 3;
+
+    /* first see if property already exists */
+    prop = XIFetchDeviceProperty (dev, property);
+    if (!prop)   /* just add to list */
+    {
+        prop = XICreateDeviceProperty (property);
+        if (!prop)
+            return(BadAlloc);
+        add = TRUE;
+        mode = PropModeReplace;
+    }
+    prop_value = &prop->value;
+
+    /* To append or prepend to a property the request format and type
+     must match those of the already defined property.  The
+     existing format and type are irrelevant when using the mode
+     "PropModeReplace" since they will be written over. */
+
+    if ((format != prop_value->format) && (mode != PropModeReplace))
+        return(BadMatch);
+    if ((prop_value->type != type) && (mode != PropModeReplace))
+        return(BadMatch);
+    new_value = *prop_value;
+    if (mode == PropModeReplace)
+        total_len = len;
+    else
+        total_len = prop_value->size + len;
+
+    if (mode == PropModeReplace || len > 0)
+    {
+        pointer            new_data = NULL, old_data = NULL;
+
+        total_size = total_len * size_in_bytes;
+        new_value.data = (pointer)xalloc (total_size);
+        if (!new_value.data && total_size)
+        {
+            if (add)
+                XIDestroyDeviceProperty (prop);
+            return BadAlloc;
+        }
+        new_value.size = len;
+        new_value.type = type;
+        new_value.format = format;
+
+        switch (mode) {
+        case PropModeReplace:
+            new_data = new_value.data;
+            old_data = NULL;
+            break;
+        case PropModeAppend:
+            new_data = (pointer) (((char *) new_value.data) +
+                                  (prop_value->size * size_in_bytes));
+            old_data = new_value.data;
+            break;
+        case PropModePrepend:
+            new_data = new_value.data;
+            old_data = (pointer) (((char *) new_value.data) +
+                                  (prop_value->size * size_in_bytes));
+            break;
+        }
+        if (new_data)
+            memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
+        if (old_data)
+            memcpy ((char *) old_data, (char *) prop_value->data,
+                    prop_value->size * size_in_bytes);
+
+        if (dev->properties.handlers)
+        {
+            XIPropertyHandlerPtr handler = dev->properties.handlers;
+            while(handler)
+            {
+                if (handler->SetProperty)
+                {
+                    rc = handler->SetProperty(dev, prop->propertyName,
+                                              &new_value);
+                    if (rc != Success)
+                    {
+                        if (new_value.data)
+                            xfree (new_value.data);
+                        return (rc);
+                    }
+                }
+                handler = handler->next;
+            }
+        }
+        if (prop_value->data)
+            xfree (prop_value->data);
+        *prop_value = new_value;
+    } else if (len == 0)
+    {
+        /* do nothing */
+    }
+
+    if (add)
+    {
+        prop->next = dev->properties.properties;
+        dev->properties.properties = prop;
+    }
+
+    if (sendevent)
+    {
+        event.type      = DevicePropertyNotify;
+        event.deviceid  = dev->id;
+        event.state     = PropertyNewValue;
+        event.atom      = prop->propertyName;
+        event.time      = currentTime.milliseconds;
+        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
+                              (xEvent*)&event, 1);
+    }
+    return(Success);
+}
+
+int
+XIGetDeviceProperty (DeviceIntPtr dev, Atom property, XIPropertyValuePtr *value)
+{
+    XIPropertyPtr   prop = XIFetchDeviceProperty (dev, property);
+    int rc;
+
+    if (!prop)
+    {
+        *value = NULL;
+        return BadAtom;
+    }
+
+    /* If we can, try to update the property value first */
+    if (dev->properties.handlers)
+    {
+        XIPropertyHandlerPtr handler = dev->properties.handlers;
+        while(handler)
+        {
+            if (handler->GetProperty)
+            {
+                rc = handler->GetProperty(dev, prop->propertyName);
+                if (rc != Success)
+                {
+                    *value = NULL;
+                    return rc;
+                }
+            }
+        }
+    }
+    *value = &prop->value;
+    return Success;
+}
+
+int
+XISetDevicePropertyDeletable(DeviceIntPtr dev, Atom property, Bool deletable)
+{
+    XIPropertyPtr prop = XIFetchDeviceProperty(dev, property);
+
+    if (!prop)
+        return BadAtom;
+
+    prop->deletable = deletable;
+    return Success;
+}
+
+int
+ProcXListDeviceProperties (ClientPtr client)
+{
+    Atom                        *pAtoms = NULL, *temppAtoms;
+    xListDevicePropertiesReply  rep;
+    int                         numProps = 0;
+    DeviceIntPtr                dev;
+    XIPropertyPtr               prop;
+    int                         rc = Success;
+
+    REQUEST(xListDevicePropertiesReq);
+    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
+
+    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixReadAccess);
+    if (rc != Success)
+        return rc;
+
+    for (prop = dev->properties.properties; prop; prop = prop->next)
+        numProps++;
+    if (numProps)
+        if(!(pAtoms = (Atom *)xalloc(numProps * sizeof(Atom))))
+            return(BadAlloc);
+
+    rep.repType = X_Reply;
+    rep.RepType = X_ListDeviceProperties;
+    rep.length = (numProps * sizeof(Atom)) >> 2;
+    rep.sequenceNumber = client->sequence;
+    rep.nAtoms = numProps;
+    if (client->swapped)
+    {
+        int n;
+        swaps (&rep.sequenceNumber, n);
+        swapl (&rep.length, n);
+    }
+    temppAtoms = pAtoms;
+    for (prop = dev->properties.properties; prop; prop = prop->next)
+        *temppAtoms++ = prop->propertyName;
+
+    WriteReplyToClient(client, sizeof(xListDevicePropertiesReply), &rep);
+    if (numProps)
+    {
+        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
+        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
+        xfree(pAtoms);
+    }
+    return rc;
+}
+
+int
+ProcXChangeDeviceProperty (ClientPtr client)
+{
+    REQUEST(xChangeDevicePropertyReq);
+    DeviceIntPtr        dev;
+    char                format, mode;
+    unsigned long       len;
+    int                 sizeInBytes;
+    int                 totalSize;
+    int                 rc;
+
+    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
+    UpdateCurrentTime();
+    format = stuff->format;
+    mode = stuff->mode;
+    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
+        (mode != PropModePrepend))
+    {
+        client->errorValue = mode;
+        return BadValue;
+    }
+    if ((format != 8) && (format != 16) && (format != 32))
+    {
+        client->errorValue = format;
+        return BadValue;
+    }
+    len = stuff->nUnits;
+    if (len > ((0xffffffff - sizeof(xChangePropertyReq)) >> 2))
+        return BadLength;
+    sizeInBytes = format>>3;
+    totalSize = len * sizeInBytes;
+    REQUEST_FIXED_SIZE(xChangeDevicePropertyReq, totalSize);
+
+    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixWriteAccess);
+    if (rc != Success)
+        return rc;
+
+    if (!ValidAtom(stuff->property))
+    {
+        client->errorValue = stuff->property;
+        return(BadAtom);
+    }
+    if (!ValidAtom(stuff->type))
+    {
+        client->errorValue = stuff->type;
+        return(BadAtom);
+    }
+
+    rc = XIChangeDeviceProperty(dev, stuff->property,
+                                 stuff->type, (int)format,
+                                 (int)mode, len, (pointer)&stuff[1], TRUE);
+
+    if (rc != Success)
+        client->errorValue = stuff->property;
+    return rc;
+}
+
+int
+ProcXDeleteDeviceProperty (ClientPtr client)
+{
+    REQUEST(xDeleteDevicePropertyReq);
+    DeviceIntPtr        dev;
+    int                 rc;
+
+    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
+    UpdateCurrentTime();
+    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixWriteAccess);
+    if (rc != Success)
+        return rc;
+
+    if (!ValidAtom(stuff->property))
+    {
+        client->errorValue = stuff->property;
+        return (BadAtom);
+    }
+
+    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
+    return rc;
+}
+
+int
+ProcXGetDeviceProperty (ClientPtr client)
+{
+    REQUEST(xGetDevicePropertyReq);
+    XIPropertyPtr               prop, *prev;
+    XIPropertyValuePtr          prop_value;
+    unsigned long               n, len, ind;
+    DeviceIntPtr                dev;
+    xGetDevicePropertyReply     reply;
+    int                         rc;
+
+    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
+    if (stuff->delete)
+        UpdateCurrentTime();
+    rc = dixLookupDevice (&dev, stuff->deviceid, client,
+                           stuff->delete ? DixWriteAccess :
+                           DixReadAccess);
+    if (rc != Success)
+        return rc;
+
+    if (!ValidAtom(stuff->property))
+    {
+        client->errorValue = stuff->property;
+        return(BadAtom);
+    }
+    if ((stuff->delete != xTrue) && (stuff->delete != xFalse))
+    {
+        client->errorValue = stuff->delete;
+        return(BadValue);
+    }
+    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type))
+    {
+        client->errorValue = stuff->type;
+        return(BadAtom);
+    }
+
+    for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
+        if (prop->propertyName == stuff->property)
+            break;
+
+    reply.repType = X_Reply;
+    reply.RepType = X_GetDeviceProperty;
+    reply.sequenceNumber = client->sequence;
+    reply.deviceid = dev->id;
+    if (!prop)
+    {
+        reply.nItems = 0;
+        reply.length = 0;
+        reply.bytesAfter = 0;
+        reply.propertyType = None;
+        reply.format = 0;
+        WriteReplyToClient(client, sizeof(xGetDevicePropertyReply), &reply);
+        return(client->noClientException);
+    }
+
+    rc = XIGetDeviceProperty(dev, stuff->property, &prop_value);
+    if (rc != Success)
+    {
+        client->errorValue = stuff->property;
+        return rc;
+    }
+
+    /* If the request type and actual type don't match. Return the
+    property information, but not the data. */
+
+    if (((stuff->type != prop_value->type) &&
+         (stuff->type != AnyPropertyType))
+       )
+    {
+        reply.bytesAfter = prop_value->size;
+        reply.format = prop_value->format;
+        reply.length = 0;
+        reply.nItems = 0;
+        reply.propertyType = prop_value->type;
+        WriteReplyToClient(client, sizeof(xGetDevicePropertyReply), &reply);
+        return(client->noClientException);
+    }
+
+/*
+ *  Return type, format, value to client
+ */
+    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
+    ind = stuff->longOffset << 2;
+
+   /* If longOffset is invalid such that it causes "len" to
+            be negative, it's a value error. */
+
+    if (n < ind)
+    {
+        client->errorValue = stuff->longOffset;
+        return BadValue;
+    }
+
+    len = min(n - ind, 4 * stuff->longLength);
+
+    reply.bytesAfter = n - (ind + len);
+    reply.format = prop_value->format;
+    reply.length = (len + 3) >> 2;
+    if (prop_value->format)
+        reply.nItems = len / (prop_value->format / 8);
+    else
+        reply.nItems = 0;
+    reply.propertyType = prop_value->type;
+
+    if (stuff->delete && (reply.bytesAfter == 0))
+    {
+        devicePropertyNotify    event;
+
+        event.type      = DevicePropertyNotify;
+        event.deviceid  = dev->id;
+        event.state     = PropertyDelete;
+        event.atom      = prop->propertyName;
+        event.time      = currentTime.milliseconds;
+        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
+                              (xEvent*)&event, 1);
+    }
+
+    WriteReplyToClient(client, sizeof(xGenericReply), &reply);
+    if (len)
+    {
+        switch (reply.format) {
+        case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
+        case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
+        default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
+        }
+        WriteSwappedDataToClient(client, len,
+                                 (char *)prop_value->data + ind);
+    }
+
+    if (stuff->delete && (reply.bytesAfter == 0))
+    { /* delete the Property */
+        *prev = prop->next;
+        XIDestroyDeviceProperty (prop);
+    }
+    return(client->noClientException);
+}
+
+
+int
+SProcXListDeviceProperties (ClientPtr client)
+{
+    REQUEST(xListDevicePropertiesReq);
+
+    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
+    (void) stuff;
+    return BadImplementation;
+}
+
+int
+SProcXChangeDeviceProperty (ClientPtr client)
+{
+    REQUEST(xChangeDevicePropertyReq);
+
+    REQUEST_SIZE_MATCH(xChangeDevicePropertyReq);
+    (void) stuff;
+    return BadImplementation;
+}
+
+int
+SProcXDeleteDeviceProperty (ClientPtr client)
+{
+    REQUEST(xDeleteDevicePropertyReq);
+
+    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
+    (void) stuff;
+    return BadImplementation;
+}
+
+int
+SProcXGetDeviceProperty (ClientPtr client)
+{
+    REQUEST(xGetDevicePropertyReq);
+
+    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
+    (void) stuff;
+    return BadImplementation;
+}
+
+/* Reply swapping */
+
+void
+SRepXListDeviceProperties(ClientPtr client, int size,
+                          xListDevicePropertiesReply *rep)
+{
+    char n;
+    swaps(&rep->sequenceNumber, n);
+    swapl(&rep->length, n);
+    swaps(&rep->nAtoms, n);
+    /* properties will be swapped later, see ProcXListDeviceProperties */
+    WriteToClient(client, size, (char*)rep);
+}
+
+void
+SRepXGetDeviceProperty(ClientPtr client, int size,
+                       xGetDevicePropertyReply *rep)
+{
+    char n;
+
+    swaps(&rep->sequenceNumber, n);
+    swapl(&rep->length, n);
+    swapl(&rep->propertyType, n);
+    swapl(&rep->bytesAfter, n);
+    swapl(&rep->nItems, n);
+    /* data will be swapped, see ProcXGetDeviceProperty */
+    WriteToClient(client, size, (char*)rep);
+}
+
Index: xorg-server/Xi/xiproperty.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/Xi/xiproperty.h	2008-09-27 00:32:51.000000000 +0300
@@ -0,0 +1,49 @@
+/*
+ * Copyright © 2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifndef XIPROPERTY_C
+#define XIPROPERTY_C
+
+int ProcXListDeviceProperties     (ClientPtr client);
+int ProcXChangeDeviceProperty     (ClientPtr client);
+int ProcXDeleteDeviceProperty     (ClientPtr client);
+int ProcXGetDeviceProperty        (ClientPtr client);
+
+/* request swapping */
+int SProcXListDeviceProperties    (ClientPtr client);
+int SProcXChangeDeviceProperty    (ClientPtr client);
+int SProcXDeleteDeviceProperty    (ClientPtr client);
+int SProcXGetDeviceProperty       (ClientPtr client);
+
+/* reply swapping */
+
+void SRepXListDeviceProperties(ClientPtr client, int size,
+                               xListDevicePropertiesReply *rep);
+void SRepXGetDeviceProperty(ClientPtr client, int size,
+                            xGetDevicePropertyReply *rep);
+
+void XIInitKnownProperties(void);
+
+#endif /* XIPROPERTY_C */
Index: xorg-server/dix/devices.c
===================================================================
--- xorg-server.orig/dix/devices.c	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/dix/devices.c	2008-09-27 00:32:51.000000000 +0300
@@ -57,6 +57,7 @@
 #define NEED_EVENTS
 #define NEED_REPLIES
 #include <X11/Xproto.h>
+#include <X11/Xatom.h>
 #include "windowstr.h"
 #include "inputstr.h"
 #include "scrnintstr.h"
@@ -80,6 +81,8 @@
 #include <X11/extensions/XIproto.h>
 #include "exglobals.h"
 #include "exevents.h"
+#include "xiproperty.h"
+#include "xserver-properties.h"
 
 /** @file
  * This file handles input device-related stuff.
@@ -87,6 +90,29 @@
 
 DevPrivateKey CoreDevicePrivateKey = &CoreDevicePrivateKey;
 
+
+/**
+ * DIX property handler.
+ */
+static int
+DeviceSetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop)
+{
+    if (property == XIGetKnownProperty(XI_PROP_ENABLED))
+    {
+        if (prop->format != 8 || prop->type != XA_INTEGER || prop->size != 1)
+            return BadValue;
+
+        if ((*((CARD8*)prop->data)) && !dev->enabled)
+            EnableDevice(dev);
+        else if (!(*((CARD8*)prop->data)) && dev->enabled)
+            DisableDevice(dev);
+    }
+
+    return Success;
+}
+
+
+
 /**
  * Create a new input device and init it to sane values. The device is added
  * to the server's off_devices list.
@@ -155,6 +181,10 @@
     dev->inited = FALSE;
     dev->enabled = FALSE;
 
+    /* device properties */
+    dev->properties.properties = NULL;
+    dev->properties.handlers = NULL;
+
     /*  security creation/labeling check
      */
     if (XaceHook(XACE_DEVICE_ACCESS, serverClient, dev, DixCreateAccess)) {
@@ -169,6 +199,12 @@
     *prev = dev;
     dev->next = NULL;
 
+    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
+                           XA_INTEGER, 8, PropModeReplace, 1, &dev->enabled,
+                           FALSE);
+    XISetDevicePropertyDeletable(dev, XIGetKnownProperty(XI_PROP_ENABLED), FALSE);
+    XIRegisterPropertyHandler(dev, DeviceSetProperty, NULL, NULL);
+
     return dev;
 }
 
@@ -206,6 +242,10 @@
     *prev = dev;
     dev->next = NULL;
 
+    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
+                           XA_INTEGER, 8, PropModeReplace, 1, &dev->enabled,
+                           TRUE);
+
     ev.type = DevicePresenceNotify;
     ev.time = currentTime.milliseconds;
     ev.devchange = DeviceEnabled;
@@ -243,6 +283,10 @@
     dev->next = inputInfo.off_devices;
     inputInfo.off_devices = dev;
 
+    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
+                           XA_INTEGER, 8, PropModeReplace, 1, &dev->enabled,
+                           TRUE);
+
     ev.type = DevicePresenceNotify;
     ev.time = currentTime.milliseconds;
     ev.devchange = DeviceDisabled;
@@ -515,6 +559,8 @@
     BellFeedbackPtr b, bnext;
     LedFeedbackPtr l, lnext;
 
+    XIDeleteAllDeviceProperties(dev);
+
     if (dev->inited)
 	(void)(*dev->deviceProc)(dev, DEVICE_CLOSE);
 
Index: xorg-server/include/exevents.h
===================================================================
--- xorg-server.orig/include/exevents.h	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/include/exevents.h	2008-09-27 00:32:51.000000000 +0300
@@ -173,10 +173,64 @@
 	Mask                   /* mask */,
 	int                    /* maskndx */);
 
-void SendEventToAllWindows(
+extern void SendEventToAllWindows(
         DeviceIntPtr           /* dev */,
         Mask                   /* mask */,
         xEvent *               /* ev */,
         int                    /* count */);
 
+/* Input device properties */
+extern void XIDeleteAllDeviceProperties(
+        DeviceIntPtr            /* device */
+);
+
+extern int XIDeleteDeviceProperty(
+        DeviceIntPtr            /* device */,
+        Atom                    /* property */,
+        Bool                    /* fromClient */
+);
+
+extern int XIChangeDeviceProperty(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        Atom                    /* type */,
+        int                     /* format*/,
+        int                     /* mode*/,
+        unsigned long           /* len*/,
+        pointer                 /* value*/,
+        Bool                    /* sendevent*/
+        );
+
+extern int XIGetDeviceProperty(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        XIPropertyValuePtr*     /* value */
+);
+
+extern int XISetDevicePropertyDeletable(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        Bool                    /* deletable */
+);
+
+extern long XIRegisterPropertyHandler(
+        DeviceIntPtr         dev,
+        int (*SetProperty) (DeviceIntPtr dev,
+                             Atom property,
+                             XIPropertyValuePtr prop),
+        int (*GetProperty) (DeviceIntPtr dev,
+                             Atom property),
+        int (*DeleteProperty) (DeviceIntPtr dev,
+                               Atom property)
+);
+
+extern void XIUnRegisterPropertyHandler(
+        DeviceIntPtr          dev,
+        long                  id
+);
+
+extern Atom XIGetKnownProperty(
+        char*                 name
+);
+
 #endif /* EXEVENTS_H */
Index: xorg-server/include/inputstr.h
===================================================================
--- xorg-server.orig/include/inputstr.h	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/include/inputstr.h	2008-09-27 00:32:51.000000000 +0300
@@ -266,6 +266,41 @@
 #endif
 } LedFeedbackClassRec;
 
+
+/* Device properties */
+typedef struct _XIPropertyValue
+{
+    Atom                type;           /* ignored by server */
+    short               format;         /* format of data for swapping - 8,16,32 */
+    long                size;           /* size of data in (format/8) bytes */
+    pointer             data;           /* private to client */
+} XIPropertyValueRec;
+
+typedef struct _XIProperty
+{
+    struct _XIProperty   *next;
+    Atom                 propertyName;
+    BOOL                 deletable;    /* clients can delete this prop? */
+    XIPropertyValueRec   value;
+} XIPropertyRec;
+
+typedef XIPropertyRec      *XIPropertyPtr;
+typedef XIPropertyValueRec *XIPropertyValuePtr;
+
+
+typedef struct _XIPropertyHandler
+{
+    struct _XIPropertyHandler* next;
+    long id;
+    int (*SetProperty) (DeviceIntPtr dev,
+                         Atom property,
+                         XIPropertyValuePtr prop);
+    int (*GetProperty) (DeviceIntPtr dev,
+                         Atom property);
+    int (*DeleteProperty) (DeviceIntPtr dev,
+                           Atom property);
+} XIPropertyHandler, *XIPropertyHandlerPtr;
+
 /* states for devices */
 
 #define NOT_GRABBED		0
@@ -332,6 +367,12 @@
     PrivateRec		*devPrivates;
     int			nPrivates;
     DeviceUnwrapProc    unwrapProc;
+
+    /* Input device property handling. */
+    struct {
+        XIPropertyPtr   properties;
+        XIPropertyHandlerPtr handlers; /* NULL-terminated */
+    } properties;
 } DeviceIntRec;
 
 typedef struct {
Index: xorg-server/include/xserver-properties.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/include/xserver-properties.h	2008-09-27 00:32:51.000000000 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software")
+ * to deal in the software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * them Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTIBILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/* Properties managed by the server. */
+
+#ifndef _XSERVER_PROPERTIES_H_
+#define _XSERVER_PROPERTIES_H_
+
+/* BOOL. 0 - device disabled, 1 - device enabled */
+#define XI_PROP_ENABLED      "Device Enabled"
+
+#endif
Index: xorg-server/include/Makefile.am
===================================================================
--- xorg-server.orig/include/Makefile.am	2008-09-27 00:32:44.000000000 +0300
+++ xorg-server/include/Makefile.am	2008-09-27 00:32:51.000000000 +0300
@@ -53,6 +53,7 @@
 	xkbfile.h	\
 	xkbsrv.h	\
 	xkbstr.h	\
+	xserver-properties.h \
 	xorg-server.h
 endif
 
