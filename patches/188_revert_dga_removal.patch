commit 507e57381fea6334f7dc8da6925e53d2c76fddcb
Author: Keith Packard <keithp@keithp.com>
Date:   Fri Sep 18 21:12:17 2009 -0700

    xfree86/modes: Remove all framebuffer support from DGA
    
    This removes all rendering and mapping code from xf86DiDGA, leaving
    just mode setting and raw input device access. The mapping code didn't
    have the offset within /dev/mem for the frame buffer and the pixmap
    support assumed that the framebuffer was never reallocated.
    (cherry picked from 0b7c6c728c2e2d8433a188315cc591308a89cd85)
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>

diff --git a/hw/xfree86/modes/xf86Crtc.c b/hw/xfree86/modes/xf86Crtc.c
index e9bde36..899cea5 100644
+-- a/hw/xfree86/modes/xf86Crtc.c
-++ b/hw/xfree86/modes/xf86Crtc.c
@@ -769,6 +769,9 @@ xf86CrtcScreenInit (ScreenPtr screen)
     config->CloseScreen = screen->CloseScreen;
     screen->CloseScreen = xf86CrtcCloseScreen;
     
-#ifdef XFreeXDGA
-    xf86DiDGAInit(screen, 0);
-#endif
 #ifdef RANDR_13_INTERFACE
     return RANDR_INTERFACE_VERSION;
 #else
@@ -1882,6 +1885,10 @@ xf86SetScrnInfoModes (ScrnInfoPtr scrn)
 	}
     }
     scrn->currentMode = scrn->modes;
-#ifdef XFreeXDGA
-    if (scrn->pScreen)
-	    xf86DiDGAReInit(scrn->pScreen);
-#endif
 }
 
 static void
diff --git a/hw/xfree86/modes/xf86DiDGA.c b/hw/xfree86/modes/xf86DiDGA.c
index f40d0ab..3992c09 100644
+-- a/hw/xfree86/modes/xf86DiDGA.c
-++ b/hw/xfree86/modes/xf86DiDGA.c
@@ -72,8 +72,7 @@ xf86_dga_get_modes (ScreenPtr pScreen)
 	mode = modes + num++;
 
 	mode->mode = display_mode;
+	mode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
+        mode->flags |= DGA_FILL_RECT | DGA_BLIT_RECT;
-	mode->flags = DGA_CONCURRENT_ACCESS;
 	if (display_mode->Flags & V_DBLSCAN)
 	    mode->flags |= DGA_DOUBLESCAN;
 	if (display_mode->Flags & V_INTERLACE)
@@ -91,14 +90,14 @@ xf86_dga_get_modes (ScreenPtr pScreen)
 	mode->yViewportStep = 1;
 	mode->viewportFlags = DGA_FLIP_RETRACE;
 	mode->offset = 0;
+	mode->address = (unsigned char *) xf86_config->dga_address;
+	mode->bytesPerScanline = xf86_config->dga_stride;
+	mode->imageWidth = xf86_config->dga_width;
+	mode->imageHeight = xf86_config->dga_height;
-	mode->address = 0;
-	mode->imageWidth = mode->viewportWidth;
-	mode->imageHeight = mode->viewportHeight;
-	mode->bytesPerScanline = (mode->imageWidth * scrn->bitsPerPixel) >> 3;
 	mode->pixmapWidth = mode->imageWidth;
 	mode->pixmapHeight = mode->imageHeight;
+	mode->maxViewportX = mode->imageWidth -	mode->viewportWidth;
+	mode->maxViewportY = mode->imageHeight - mode->viewportHeight;
-	mode->maxViewportX = 0;
-	mode->maxViewportY = 0;
 
 	display_mode = display_mode->next;
 	if (display_mode == scrn->modes)
@@ -149,93 +148,11 @@ xf86_dga_set_viewport(ScrnInfoPtr scrn, int x, int y, int flags)
 }
 
 static Bool
+xf86_dga_get_drawable_and_gc (ScrnInfoPtr scrn, DrawablePtr *ppDrawable, GCPtr *ppGC)
+{
+    ScreenPtr		pScreen = scrn->pScreen;
+    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    PixmapPtr		pPixmap;
+    GCPtr		pGC;
+    
+    pPixmap = GetScratchPixmapHeader (pScreen, xf86_config->dga_width, xf86_config->dga_height,
+				      scrn->depth, scrn->bitsPerPixel, xf86_config->dga_stride, 
+				      (char *) scrn->memPhysBase + scrn->fbOffset);
+    if (!pPixmap)
+	return FALSE;
+    pGC  = GetScratchGC (scrn->depth, pScreen);
+    if (!pGC)
+    {
+	FreeScratchPixmapHeader (pPixmap);
+	return FALSE;
+    }
+    *ppDrawable = &pPixmap->drawable;
+    *ppGC = pGC;
+    return TRUE;
+}
+
+static void
+xf86_dga_release_drawable_and_gc (ScrnInfoPtr scrn, DrawablePtr pDrawable, GCPtr pGC)
+{
+    FreeScratchGC (pGC);
+    FreeScratchPixmapHeader ((PixmapPtr) pDrawable);
+}
+
+static void
+xf86_dga_fill_rect(ScrnInfoPtr scrn, int x, int y, int w, int h, unsigned long color)
+{
+    GCPtr		pGC;
+    DrawablePtr		pDrawable;
+    XID			vals[1];
+    xRectangle		r;
+
+    if (!xf86_dga_get_drawable_and_gc (scrn, &pDrawable, &pGC))
+	return;
+    vals[0] = color;
+    ChangeGC (pGC, GCForeground, vals);
+    ValidateGC (pDrawable, pGC);
+    r.x = x;
+    r.y = y;
+    r.width = w;
+    r.height = h;
+    pGC->ops->PolyFillRect (pDrawable, pGC, 1, &r);
+    xf86_dga_release_drawable_and_gc (scrn, pDrawable, pGC);
+}
+
+static void
+xf86_dga_sync(ScrnInfoPtr scrn)
+{
+    ScreenPtr	pScreen = scrn->pScreen;
+    WindowPtr	pRoot = WindowTable [pScreen->myNum];
+    char	buffer[4];
+
+    pScreen->GetImage (&pRoot->drawable, 0, 0, 1, 1, ZPixmap, ~0L, buffer);
+}
+
+static void
+xf86_dga_blit_rect(ScrnInfoPtr scrn, int srcx, int srcy, int w, int h, int dstx, int dsty)
+{
+    DrawablePtr	pDrawable;
+    GCPtr	pGC;
+
+    if (!xf86_dga_get_drawable_and_gc (scrn, &pDrawable, &pGC))
+	return;
+    ValidateGC (pDrawable, pGC);
+    pGC->ops->CopyArea (pDrawable, pDrawable, pGC, srcx, srcy, w, h, dstx, dsty);
+    xf86_dga_release_drawable_and_gc (scrn, pDrawable, pGC);
+}
+
+static Bool
 xf86_dga_open_framebuffer(ScrnInfoPtr scrn,
 			  char **name,
 			  unsigned char **mem, int *size, int *offset, int *flags)
 {
+    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    
+    *size = xf86_config->dga_stride * xf86_config->dga_height;
+    *mem = (unsigned char *) (xf86_config->dga_address);
+    *offset = 0;
+    *flags = DGA_NEED_ROOT;
+
+    return TRUE;
-    return FALSE;
 }
 
 static void
@@ -249,9 +166,9 @@ static DGAFunctionRec xf86_dga_funcs = {
    xf86_dga_set_mode,
    xf86_dga_set_viewport,
    xf86_dga_get_viewport,
+   xf86_dga_sync,
+   xf86_dga_fill_rect,
+   xf86_dga_blit_rect,
-   NULL,
-   NULL,
-   NULL,
    NULL
 };
 
@@ -261,6 +178,9 @@ xf86DiDGAReInit (ScreenPtr pScreen)
     ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
     
-    if (!DGAAvailable(pScreen->myNum))
-	return TRUE;
-
     if (!xf86_dga_get_modes (pScreen))
 	return FALSE;
     
@@ -273,11 +193,14 @@ xf86DiDGAInit (ScreenPtr pScreen, unsigned long dga_address)
     ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
 
-    if (DGAAvailable(pScreen->myNum))
-	return TRUE;
-
     xf86_config->dga_flags = 0;
+    xf86_config->dga_address = dga_address;
+    xf86_config->dga_width = scrn->virtualX;
+    xf86_config->dga_height = scrn->virtualY;
+    xf86_config->dga_stride = scrn->displayWidth * scrn->bitsPerPixel >> 3;
-    xf86_config->dga_address = 0;
-    xf86_config->dga_width = 0;
-    xf86_config->dga_height = 0;
-    xf86_config->dga_stride = 0;
     
     if (!xf86_dga_get_modes (pScreen))
 	return FALSE;
diff --git a/hw/xfree86/modes/xf86RandR12.c b/hw/xfree86/modes/xf86RandR12.c
index 4546492..0637ed5 100644
+-- a/hw/xfree86/modes/xf86RandR12.c
-++ b/hw/xfree86/modes/xf86RandR12.c
@@ -1,5 +1,5 @@
 /*
+ * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
- * Copyright Â© 2002 Keith Packard, member of The XFree86 Project, Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -460,7 +460,6 @@ xf86RandR12GetInfo (ScreenPtr pScreen, Rotation *rotations)
     {
 	xf86ProbeOutputModes (scrp, 0, 0);
 	xf86SetScrnInfoModes (scrp);
+	xf86DiDGAReInit (pScreen);
     }
 
     for (mode = scrp->modes; ; mode = mode->next)
@@ -1481,7 +1480,6 @@ xf86RandR12GetInfo12 (ScreenPtr pScreen, Rotation *rotations)
 	return TRUE;
     xf86ProbeOutputModes (pScrn, 0, 0);
     xf86SetScrnInfoModes (pScrn);
+    xf86DiDGAReInit (pScreen);
     return xf86RandR12SetInfo12 (pScreen);
 }
 
