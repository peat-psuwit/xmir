Index: xorg-server/configure.ac
===================================================================
--- xorg-server.orig/configure.ac	2006-10-31 17:25:45.000000000 +0100
+++ xorg-server/configure.ac	2006-10-31 17:27:54.000000000 +0100
@@ -1177,6 +1177,10 @@
 			XORG_CFLAGS="${XORG_CFLAGS} "'$(SOLARIS_ASM_CFLAGS)'
 		fi
 		;;
+	  gnu*)
+	  	XORG_OS="gnu"
+		XORG_OS_SUBDIR="hurd"
+		;;
 	  *)
 	  	XORG_OS="unknown"
 		XORG_OS_SUBDIR="unknown"
@@ -1477,7 +1481,15 @@
     #    $MIEXT_SHADOW_LIB $XPSTUBS_LIB"
     KDRIVE_PURE_LIBS="$FB_LIB $MI_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $XTRAP_LIB $RECORD_LIB $GLX_LIBS $RENDER_LIB $RANDR_LIB $DAMAGE_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $XPSTUBS_LIB $OS_LIB"
     KDRIVE_LIB='$(top_builddir)/hw/kdrive/src/libkdrive.a'
-    KDRIVE_OS_LIB='$(top_builddir)/hw/kdrive/linux/liblinux.a'
+    case $host_os in
+	*linux*)
+	    KDRIVE_OS_LIB='$(top_builddir)/hw/kdrive/linux/liblinux.a'
+	    AM_CONDITIONAL(KDRIVELINUX, true)
+	    ;;
+	*)
+	    AM_CONDITIONAL(KDRIVELINUX, false)
+	    ;;
+    esac
     KDRIVE_STUB_LIB='$(top_builddir)/hw/kdrive/src/libkdrivestubs.a'
     KDRIVE_LIBS="$DIX_LIB $KDRIVE_LIB $KDRIVE_OS_LIB $KDRIVE_PURE_LIBS $KDRIVE_STUB_LIB"
 
@@ -1706,6 +1718,7 @@
 hw/xfree86/os-support/solaris/Makefile
 hw/xfree86/os-support/sysv/Makefile
 hw/xfree86/os-support/usl/Makefile
+hw/xfree86/os-support/hurd/Makefile
 hw/xfree86/parser/Makefile
 hw/xfree86/rac/Makefile
 hw/xfree86/ramdac/Makefile
Index: xorg-server/hw/kdrive/Makefile.am
===================================================================
--- xorg-server.orig/hw/kdrive/Makefile.am	2006-10-28 16:58:28.000000000 +0200
+++ xorg-server/hw/kdrive/Makefile.am	2006-10-31 17:25:45.000000000 +0100
@@ -15,9 +15,13 @@
 XEPHYR_SUBDIRS = ephyr
 endif
 
+if KDRIVELINUX
+LINUX_SUBDIRS = linux
+endif
+
 SUBDIRS =			\
 	src			\
-	linux			\
+	$(LINUX_SUBDIRS)	\
 	$(XSDL_SUBDIRS)		\
 	$(FBDEV_SUBDIRS)	\
 	$(VESA_SUBDIRS)		\
Index: xorg-server/GL/glx/indirect_dispatch_swap.c
===================================================================
--- xorg-server.orig/GL/glx/indirect_dispatch_swap.c	2006-10-28 16:58:28.000000000 +0200
+++ xorg-server/GL/glx/indirect_dispatch_swap.c	2006-10-31 17:25:45.000000000 +0100
@@ -28,7 +28,7 @@
 #include <X11/Xmd.h>
 #include <GL/gl.h>
 #include <GL/glxproto.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
 #include <byteswap.h>
 #elif defined(__OpenBSD__)
 #include <sys/endian.h>
Index: xorg-server/GL/glx/indirect_reqsize.c
===================================================================
--- xorg-server.orig/GL/glx/indirect_reqsize.c	2006-10-28 16:58:28.000000000 +0200
+++ xorg-server/GL/glx/indirect_reqsize.c	2006-10-31 17:25:45.000000000 +0100
@@ -31,7 +31,7 @@
 #include "indirect_size.h"
 #include "indirect_reqsize.h"
 
-#if defined(linux)
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
 #  include <byteswap.h>
 #  define SWAP_32(v)  do { (v) = bswap_32(v); } while(0)
 #else
Index: xorg-server/GL/glx/indirect_util.c
===================================================================
--- xorg-server.orig/GL/glx/indirect_util.c	2006-10-28 16:58:28.000000000 +0200
+++ xorg-server/GL/glx/indirect_util.c	2006-10-31 17:25:45.000000000 +0100
@@ -28,7 +28,7 @@
 #include <X11/Xmd.h>
 #include <GL/gl.h>
 #include <GL/glxproto.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)
 #include <byteswap.h>
 #elif defined(__OpenBSD__)
 #include <sys/endian.h>
Index: xorg-server/hw/xfree86/os-support/Makefile.am
===================================================================
--- xorg-server.orig/hw/xfree86/os-support/Makefile.am	2006-10-31 17:26:58.000000000 +0100
+++ xorg-server/hw/xfree86/os-support/Makefile.am	2006-10-31 17:27:54.000000000 +0100
@@ -3,7 +3,7 @@
 endif
 
 SUBDIRS = bus @XORG_OS_SUBDIR@ misc $(DRI_SUBDIRS)
-DIST_SUBDIRS = bsd bus drm misc linux lynxos solaris sysv sco usl
+DIST_SUBDIRS = bsd bus drm misc linux lynxos solaris sysv sco usl hurd
 
 sdk_HEADERS = xf86_OSproc.h xf86_OSlib.h xf86_ansic.h xf86_libc.h \
               assyntax.h xf86OSKbd.h xf86OSmouse.h
Index: xorg-server/hw/xfree86/os-support/hurd/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/Makefile.am	2006-10-31 17:27:54.000000000 +0100
@@ -0,0 +1,18 @@
+noinst_LTLIBRARIES = libhurd.la
+
+libhurd_la_SOURCES = hurd_init.c hurd_io.c hurd_mmap.c hurd_kbd.c \
+		hurd_mouse.c hurd_video.c \
+		$(srcdir)/../shared/VTsw_noop.c \
+		$(srcdir)/../shared/posix_tty.c \
+		$(srcdir)/../shared/libc_wrapper.c \
+		$(srcdir)/../shared/stdResource.c \
+		$(srcdir)/../shared/stdPci.c \
+		$(srcdir)/../shared/sigiostubs.c \
+		$(srcdir)/../shared/pm_noop.c \
+		$(srcdir)/../shared/kmod_noop.c \
+		$(srcdir)/../shared/agp_noop.c \
+		$(srcdir)/../shared/at_scancode.c
+
+AM_CFLAGS = -DUSESTDRES -DHAVE_SYSV_IPC $(XORG_CFLAGS) @SERVER_DEFINES@ @LOADER_DEFINES@
+
+INCLUDES = $(XORG_INCS)
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_init.c	2006-10-31 17:33:02.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_init.c,v 1.1 1998/08/16 10:25:48 dawes Exp $ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+
+int
+xf86ProcessArgument( int argc,char **argv, int i )
+{
+    return 0;
+}
+void
+xf86UseMsg()
+{
+    return;
+}
+
+
+void
+xf86OpenConsole()
+{
+    if( serverGeneration == 1 )
+    {
+	kern_return_t err;
+	mach_port_t device;
+	int fd;
+	err = get_privileged_ports( NULL, &device );
+	if( err )
+	{
+	    errno = err;
+	    FatalError( "xf86KbdInit can't get_privileged_ports. (%s)\n" , strerror(errno) );
+	}
+	mach_port_deallocate (mach_task_self (), device);
+
+	if( ( fd = open( "/dev/kbd" , O_RDONLY|O_NONBLOCK ) ) < 0 )
+	{
+	    fprintf( stderr , "Cannot open keyboard (%s)\n",strerror(errno) );
+	    exit(1);
+	}
+	xf86Info.consoleFd = fd;
+    }
+    return;
+}
+
+void
+xf86CloseConsole()
+{
+    close( xf86Info.consoleFd );
+    return;
+}
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_io.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_io.c	2006-10-31 17:34:08.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c,v 1.8 2002/10/11 01:40:35 dawes Exp $ */
+
+#define NEED_EVENTS
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "inputstr.h"
+#include "scrnintstr.h"
+#include "mipointer.h"
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+#include <sys/ioctl.h>
+
+typedef unsigned short kev_type;		/* kd event type */
+typedef unsigned char Scancode;
+
+struct mouse_motion {
+    short mm_deltaX;		/* units? */
+    short mm_deltaY;
+};
+
+typedef struct {
+    kev_type type;			/* see below */
+    struct timeval time;		/* timestamp */
+    union {				/* value associated with event */
+	boolean_t up;		/* MOUSE_LEFT .. MOUSE_RIGHT */
+	Scancode sc;		/* KEYBD_EVENT */
+	struct mouse_motion mmotion;	/* MOUSE_MOTION */
+    } value;
+} kd_event;
+
+/*
+ * kd_event ID's.
+ */
+#define MOUSE_LEFT	1		/* mouse left button up/down */
+#define MOUSE_MIDDLE	2
+#define MOUSE_RIGHT	3
+#define MOUSE_MOTION	4		/* mouse motion */
+#define KEYBD_EVENT	5		/* key up/down */
+
+/***********************************************************************
+ * Keyboard
+ **********************************************************************/
+void
+xf86SoundKbdBell(int loudness,int pitch,int duration)
+{
+    return;
+}
+
+void
+xf86SetKbdLeds(int leds)
+{
+    return;
+}
+
+int
+xf86GetKbdLeds()
+{
+    return 0;
+}
+
+void
+xf86SetKbdRepeat(char rad)
+{
+    return;
+}
+
+void
+xf86KbdInit()
+{
+    return;
+}
+int
+xf86KbdOn()
+{
+    int data = 1;
+    if( ioctl( xf86Info.consoleFd, _IOW('k', 1, int),&data) < 0)
+	FatalError("Cannot set event mode on keyboard (%s)\n",strerror(errno));
+    return xf86Info.consoleFd;
+}
+int
+xf86KbdOff()
+{
+    int data = 2;
+    if( ioctl( xf86Info.consoleFd, _IOW('k', 1, int),&data) < 0)
+	FatalError("can't reset keyboard mode (%s)\n",strerror(errno));
+}
+
+void
+xf86KbdEvents()
+{
+    kd_event ke;
+    while( read(xf86Info.consoleFd, &ke, sizeof(ke)) == sizeof(ke) )
+	xf86PostKbdEvent(ke.value.sc);
+}
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_kbd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_kbd.c	2006-10-31 17:33:33.000000000 +0100
@@ -0,0 +1,176 @@
+/*
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_io.c,v 1.8 2002/10/11 01:40:35 dawes Exp $ */
+
+#define NEED_EVENTS
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+
+#include "compiler.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+#include "xf86Xinput.h"
+#include "xf86OSKbd.h"
+#include "atKeynames.h"
+#include "xf86Keymap.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+#include <sys/ioctl.h>
+
+typedef unsigned short kev_type;		/* kd event type */
+typedef unsigned char Scancode;
+
+struct mouse_motion {
+    short mm_deltaX;		/* units? */
+    short mm_deltaY;
+};
+
+typedef struct {
+    kev_type type;			/* see below */
+    struct timeval time;		/* timestamp */
+    union {				/* value associated with event */
+	boolean_t up;		/* MOUSE_LEFT .. MOUSE_RIGHT */
+	Scancode sc;		/* KEYBD_EVENT */
+	struct mouse_motion mmotion;	/* MOUSE_MOTION */
+    } value;
+} kd_event;
+
+/*
+ * kd_event ID's.
+ */
+#define MOUSE_LEFT	1		/* mouse left button up/down */
+#define MOUSE_MIDDLE	2
+#define MOUSE_RIGHT	3
+#define MOUSE_MOTION	4		/* mouse motion */
+#define KEYBD_EVENT	5		/* key up/down */
+
+/***********************************************************************
+ * Keyboard
+ **********************************************************************/
+static void
+SoundKbdBell(InputInfoPtr pInfo, int loudness,int pitch,int duration)
+{
+    return;
+}
+
+static void
+SetKbdLeds(InputInfoPtr pInfo, int leds)
+{
+    return;
+}
+
+static int
+GetKbdLeds(InputInfoPtr pInfo)
+{
+    return 0;
+}
+
+static void
+SetKbdRepeat(InputInfoPtr pInfo, char rad)
+{
+    return;
+}
+
+static void
+KbdGetMapping(InputInfoPtr pInfo, KeySymsPtr pKeySyms, CARD8 *pModMap)
+{
+    pKeySyms->map        = map;
+    pKeySyms->mapWidth   = GLYPHS_PER_KEY;
+    pKeySyms->minKeyCode = MIN_KEYCODE;
+    pKeySyms->maxKeyCode = MAX_KEYCODE;
+    return;
+}
+
+static int
+KbdOn(InputInfoPtr pInfo, int what)
+{
+    int data = 1;
+    if( ioctl( pInfo->fd, _IOW('k', 1, int),&data) < 0)
+	FatalError("Cannot set event mode on keyboard (%s)\n",strerror(errno));
+    return Success;
+}
+static int
+KbdOff(InputInfoPtr pInfo, int what)
+{
+    int data = 2;
+    if( ioctl( pInfo->fd, _IOW('k', 1, int),&data) < 0)
+	FatalError("can't reset keyboard mode (%s)\n",strerror(errno));
+    return Success;
+}
+
+static int
+KbdInit(InputInfoPtr pInfo, int what)
+{
+    return Success;
+}
+
+static void
+ReadInput(InputInfoPtr pInfo)
+{
+    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
+    kd_event ke;
+    while( read(pInfo->fd, &ke, sizeof(ke)) == sizeof(ke) )
+	pKbd->PostEvent(pInfo, ke.value.sc & 0x7f, ke.value.sc & 0x80 ? FALSE : TRUE);
+}
+
+static Bool
+OpenKeyboard(InputInfoPtr pInfo)
+{
+    pInfo->fd = xf86Info.consoleFd;
+    return TRUE;
+}
+
+Bool
+xf86OSKbdPreInit(InputInfoPtr pInfo)
+{
+    KbdDevPtr pKbd = pInfo->private;
+
+    pKbd->KbdInit       = KbdInit;
+    pKbd->KbdOn         = KbdOn;
+    pKbd->KbdOff        = KbdOff;
+    pKbd->Bell          = SoundKbdBell;
+    pKbd->SetLeds       = SetKbdLeds;
+    pKbd->GetLeds       = GetKbdLeds;
+    pKbd->SetKbdRepeat  = SetKbdRepeat;
+    pKbd->KbdGetMapping = KbdGetMapping;
+    pKbd->SpecialKey    = NULL;
+    pKbd->RemapScanCode = ATScancode;
+    pKbd->GetSpecialKey = NULL;
+    pKbd->OpenKeyboard  = OpenKeyboard;
+    pKbd->vtSwitchSupported = FALSE;
+    pKbd->CustomKeycodes = FALSE;
+    pKbd->private       = NULL;
+    pInfo->read_input   = ReadInput;
+    return TRUE;
+}
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_mmap.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_mmap.c	2006-10-31 17:30:32.000000000 +0100
@@ -0,0 +1,96 @@
+/*
+ * Copyright 1997 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86$ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include<mach.h>
+#include<device/device.h>
+#include<mach/machine/mach_i386.h>
+
+#include <X11/X.h>
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+
+#define BIOS_SIZE 0x20000
+
+int
+xf86ReadBIOS(unsigned long Base,unsigned long Offset,unsigned char *Buf,int Len)
+{
+    mach_port_t device,iopl_dev;
+    memory_object_t iopl_mem;
+    vm_address_t addr = (vm_address_t)0; /* serach starting address */
+    kern_return_t err;
+
+
+    err = get_privileged_ports (NULL, &device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't get_privileged_ports. (%s)\n",strerror(errno));
+    }
+    err = device_open(device,D_READ|D_WRITE,"iopl",&iopl_dev);
+    mach_port_deallocate (mach_task_self (), device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't device_open. (%s)\n",strerror(errno));
+    }
+    err = device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, Base , BIOS_SIZE ,&iopl_mem,0);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't device_map. (%s)\n",strerror(errno));
+    }
+    err = vm_map(mach_task_self(),
+		 &addr,
+		 BIOS_SIZE,
+		 0,
+		 TRUE,
+		 iopl_mem,
+		 Base,
+		 FALSE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_INHERIT_SHARE);
+    mach_port_deallocate(mach_task_self(),iopl_mem);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't vm_map. (%s)\n",strerror(errno));
+    }
+
+    memcpy(Buf,(void*)((int)addr + Offset), Len);
+
+    err = vm_deallocate(mach_task_self(), addr, BIOS_SIZE);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86ReadBIOS() can't vm_deallocate. (%s)\n",strerror(errno));
+    }
+
+    return Len;
+}
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_mouse.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_mouse.c	2006-10-31 17:32:34.000000000 +0100
@@ -0,0 +1,301 @@
+/*
+ * Copyright 1997,1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_mouse.c,v 1.7 2000/02/10 22:33:44 dawes Exp $ */
+
+#define NEED_EVENTS
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "inputstr.h"
+#include "scrnintstr.h"
+#include "mipointer.h"
+
+#include "xf86.h"
+#include "xf86Xinput.h"
+#include "xf86OSmouse.h"
+#include "xf86_OSlib.h"
+#include "xisb.h"
+
+#include <stdio.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <assert.h>
+#include <mach.h>
+#include <sys/ioctl.h>
+
+typedef unsigned short kev_type;		/* kd event type */
+typedef unsigned char Scancode;
+
+struct mouse_motion {
+    short mm_deltaX;		/* units? */
+    short mm_deltaY;
+};
+
+typedef struct {
+    kev_type type;			/* see below */
+    struct timeval time;		/* timestamp */
+    union {				/* value associated with event */
+	boolean_t up;		/* MOUSE_LEFT .. MOUSE_RIGHT */
+	Scancode sc;		/* KEYBD_EVENT */
+	struct mouse_motion mmotion;	/* MOUSE_MOTION */
+    } value;
+} kd_event;
+
+/*
+ * kd_event ID's.
+ */
+#define MOUSE_LEFT	1		/* mouse left button up/down */
+#define MOUSE_MIDDLE	2
+#define MOUSE_RIGHT	3
+#define MOUSE_MOTION	4		/* mouse motion */
+#define KEYBD_EVENT	5		/* key up/down */
+
+#define NUMEVENTS	64
+
+/*
+ * OsMouseProc --
+ *      Handle the initialization, etc. of a mouse
+ */
+static int
+OsMouseProc(DeviceIntPtr pPointer, int what)
+{
+    InputInfoPtr pInfo;
+    MouseDevPtr pMse;
+    unsigned char map[MSE_MAXBUTTONS + 1];
+    int nbuttons;
+
+    pInfo = pPointer->public.devicePrivate;
+    pMse = pInfo->private;
+    pMse->device = pPointer;
+
+    switch (what) {
+    case DEVICE_INIT:
+	pPointer->public.on = FALSE;
+
+	for (nbuttons = 0; nbuttons < MSE_MAXBUTTONS; ++nbuttons)
+	    map[nbuttons + 1] = nbuttons + 1;
+
+	InitPointerDeviceStruct((DevicePtr)pPointer,
+				map,
+				min(pMse->buttons, MSE_MAXBUTTONS),
+				miPointerGetMotionEvents,
+				pMse->Ctrl,
+				miPointerGetMotionBufferSize());
+
+	/* X valuator */
+	xf86InitValuatorAxisStruct(pPointer, 0, 0, -1, 1, 0, 1);
+	xf86InitValuatorDefaults(pPointer, 0);
+	/* Y valuator */
+	xf86InitValuatorAxisStruct(pPointer, 1, 0, -1, 1, 0, 1);
+	xf86InitValuatorDefaults(pPointer, 1);
+	xf86MotionHistoryAllocate(pInfo);
+	break;
+
+    case DEVICE_ON:
+	pInfo->fd = xf86OpenSerial(pInfo->options);
+	if (pInfo->fd == -1)
+	    xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
+	else {
+	    pMse->buffer = XisbNew(pInfo->fd,
+				   NUMEVENTS * sizeof(kd_event));
+	    if (!pMse->buffer) {
+		xfree(pMse);
+		xf86CloseSerial(pInfo->fd);
+		pInfo->fd = -1;
+	    } else {
+		xf86FlushInput(pInfo->fd);
+		AddEnabledDevice(pInfo->fd);
+	    }
+	}
+	pMse->lastButtons = 0;
+	pMse->lastMappedButtons = 0;
+	pMse->emulateState = 0;
+	pPointer->public.on = TRUE;
+	break;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+	if (pInfo->fd != -1) {
+	    RemoveEnabledDevice(pInfo->fd);
+	    if (pMse->buffer) {
+		XisbFree(pMse->buffer);
+		pMse->buffer = NULL;
+	    }
+	    xf86CloseSerial(pInfo->fd);
+	    pInfo->fd = -1;
+	}
+	pPointer->public.on = FALSE;
+	usleep(300000);
+	break;
+    }
+    return Success;
+}
+
+/*
+ * OsMouseReadInput --
+ *      Get some events from our queue.  Process all outstanding events now.
+ */
+static void
+OsMouseReadInput(InputInfoPtr pInfo)
+{
+    MouseDevPtr pMse;
+    static kd_event eventList[NUMEVENTS];
+    int n, c;
+    kd_event *event = eventList;
+    unsigned char *pBuf;
+
+    pMse = pInfo->private;
+
+    XisbBlockDuration(pMse->buffer, -1);
+    pBuf = (unsigned char *)eventList;
+    n = 0;
+    while ((c = XisbRead(pMse->buffer)) >= 0 && n < sizeof(eventList))
+	pBuf[n++] = (unsigned char)c;
+
+    if (n == 0)
+	return;
+
+    n /= sizeof(kd_event);
+    while( n-- ) {
+	int buttons = pMse->lastButtons;
+	int dx = 0, dy = 0;
+	switch (event->type) {
+	case MOUSE_RIGHT:
+	    buttons  = buttons & 6 |(event->value.up ? 0 : 1);
+	    break;
+	case MOUSE_MIDDLE:
+	    buttons  = buttons & 5 |(event->value.up ? 0 : 2);
+	    break;
+	case MOUSE_LEFT:
+	    buttons  = buttons & 3 |(event->value.up ? 0 : 4) ;
+	    break;
+	case MOUSE_MOTION:
+	    dx = event->value.mmotion.mm_deltaX;
+	    dy = - event->value.mmotion.mm_deltaY;
+	    break;
+	default:
+	    ErrorF("Bad mouse event (%d)\n",event->type);
+	    continue;
+	}
+	pMse->PostEvent(pInfo, buttons, dx, dy, 0, 0);
+	++event;
+    }
+    return;
+}
+
+static Bool
+OsMousePreInit(InputInfoPtr pInfo, const char *protocol, int flags)
+{
+    MouseDevPtr pMse;
+
+    /* This is called when the protocol is "OSMouse". */
+
+    pMse = pInfo->private;
+    pMse->protocol = protocol;
+    xf86Msg(X_CONFIG, "%s: Protocol: %s\n", pInfo->name, protocol);
+
+    /* Collect the options, and process the common options. */
+    xf86CollectInputOptions(pInfo, NULL, NULL);
+    xf86ProcessCommonOptions(pInfo, pInfo->options);
+
+    /* Check if the device can be opened. */
+    pInfo->fd = xf86OpenSerial(pInfo->options);
+    if (pInfo->fd == -1) {
+	if (xf86GetAllowMouseOpenFail())
+	    xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
+	else {
+	    xf86Msg(X_ERROR, "%s: cannot open input device\n", pInfo->name);
+	    xfree(pMse);
+	    return FALSE;
+	}
+    }
+    xf86CloseSerial(pInfo->fd);
+    pInfo->fd = -1;
+
+    /* Process common mouse options (like Emulate3Buttons, etc). */
+    pMse->CommonOptions(pInfo);
+
+    /* Setup the local procs. */
+    pInfo->device_control = OsMouseProc;
+    pInfo->read_input = OsMouseReadInput;
+
+    pInfo->flags |= XI86_CONFIGURED;
+    return TRUE;
+}
+
+static int
+SupportedInterfaces(void)
+{
+    /* XXX Need to check this. */
+    return MSE_SERIAL | MSE_BUS | MSE_PS2 | MSE_XPS2 | MSE_AUTO;
+}
+
+static const char *internalNames[] = {
+	"OSMouse",
+	NULL
+};
+
+static const char **
+BuiltinNames(void)
+{
+    return internalNames;
+}
+
+static Bool
+CheckProtocol(const char *protocol)
+{
+    int i;
+
+    for (i = 0; internalNames[i]; i++)
+	if (xf86NameCmp(protocol, internalNames[i]) == 0)
+	    return TRUE;
+    return FALSE;
+}
+
+/* XXX Is this appropriate?  If not, this function should be removed. */
+static const char *
+DefaultProtocol(void)
+{
+    return "OSMouse";
+}
+
+OSMouseInfoPtr
+xf86OSMouseInit(int flags)
+{
+    OSMouseInfoPtr p;
+
+    p = xcalloc(sizeof(OSMouseInfoRec), 1);
+    if (!p)
+	return NULL;
+    p->SupportedInterfaces = SupportedInterfaces;
+    p->BuiltinNames = BuiltinNames;
+    p->DefaultProtocol = DefaultProtocol;
+    p->CheckProtocol = CheckProtocol;
+    p->PreInit = OsMousePreInit;
+    return p;
+}
+
Index: xorg-server/hw/xfree86/os-support/hurd/hurd_video.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/hw/xfree86/os-support/hurd/hurd_video.c	2006-10-31 17:31:44.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ * Copyright 1997, 1998 by UCHIYAMA Yasushi
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of UCHIYAMA Yasushi not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/hurd/hurd_video.c,v 1.3 1999/04/29 12:24:52 dawes Exp $ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <mach.h>
+#include <device/device.h>
+#include <mach/machine/mach_i386.h>
+
+#include <X11/X.h>
+#include "input.h"
+#include "scrnintstr.h"
+
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86_OSlib.h"
+#include "xf86OSpriv.h"
+
+/**************************************************************************
+ * Video Memory Mapping section
+ ***************************************************************************/
+pointer
+xf86MapVidMem(int ScreenNum,int Flags, unsigned long Base, unsigned long Size)
+{
+    mach_port_t device,iopl_dev;
+    memory_object_t iopl_mem;
+    kern_return_t err;
+    vm_address_t addr=(vm_address_t)0;
+
+    err = get_privileged_ports (NULL, &device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't get_privileged_ports. (%s)\n",strerror(errno));
+    }
+    err = device_open(device,D_READ|D_WRITE,"iopl",&iopl_dev);
+    mach_port_deallocate (mach_task_self(), device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't device_open. (%s)\n",strerror(errno));
+    }
+
+    err = device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, Base , Size ,&iopl_mem,0);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't device_map. (%s)\n",strerror(errno));
+    }
+    err = vm_map(mach_task_self(),
+		 &addr,
+		 Size,
+		 0,     /* mask */
+		 TRUE,  /* anywhere */
+		 iopl_mem,
+		 (vm_offset_t)Base,
+		 FALSE, /* copy on write */
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_PROT_READ|VM_PROT_WRITE,
+		 VM_INHERIT_SHARE);
+    mach_port_deallocate(mach_task_self(),iopl_mem);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't vm_map.(iopl_mem) (%s)\n",strerror(errno));
+    }
+    mach_port_deallocate(mach_task_self(),iopl_dev);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86MapVidMem() can't mach_port_deallocate.(iopl_dev) (%s)\n",strerror(errno));
+    }
+    return (pointer)addr;
+}
+
+void
+xf86UnMapVidMem(int ScreenNum,pointer Base,unsigned long Size)
+{
+    kern_return_t err = vm_deallocate(mach_task_self(), (int)Base, Size);
+    if( err )
+    {
+	errno = err;
+	ErrorF("xf86UnMapVidMem: can't dealloc framebuffer space (%s)\n",strerror(errno));
+    }
+    return;
+}
+
+Bool
+xf86LinearVidMem()
+{
+    return(TRUE);
+}
+
+/**************************************************************************
+ * I/O Permissions section
+ ***************************************************************************/
+mach_port_t io_port;
+
+Bool
+xf86EnableIO()
+{
+    mach_port_t device;
+    kern_return_t err;
+
+    err = get_privileged_ports(NULL, &device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86EnableIO() can't get_privileged_ports. (%s)\n",strerror(errno));
+    }
+    err = device_open(device,D_READ|D_WRITE,"io",&io_port);
+    mach_port_deallocate(mach_task_self(), device);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86EnableIO() can't device_open. (%s)\n",strerror(errno));
+    }
+
+    err = i386_io_port_add(mach_thread_self (), io_port);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86EnableIO() can't i386_io_port_add.(io_port) (%s)\n",strerror(errno));
+    }
+    return TRUE;
+}
+
+void
+xf86DisableIO()
+{
+    kern_return_t err;
+
+    err = i386_io_port_remove(mach_thread_self (), io_port);
+    if( err )
+    {
+	errno = err;
+	FatalError("xf86DisableIO() can't i386_io_port_remove.(io_port) (%s)\n",strerror(errno));
+    }
+    mach_port_deallocate(mach_task_self(), io_port);
+    return;
+}
+
+/**************************************************************************
+ * Interrupt Handling section
+ **************************************************************************/
+Bool
+xf86DisableInterrupts()
+{
+    return TRUE;
+}
+void
+xf86EnableInterrupts()
+{
+    return;
+}
+
+void
+xf86MapReadSideEffects(int ScreenNum, int Flags, pointer Base,
+	unsigned long Size)
+{
+}
+
+Bool
+xf86CheckMTRR(int s)
+{
+	return FALSE;
+}
+
