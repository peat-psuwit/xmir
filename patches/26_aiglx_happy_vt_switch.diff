Index: xorg-server/GL/glx/glxdri.c
===================================================================
--- xorg-server.orig/GL/glx/glxdri.c	2006-09-28 21:42:10.000000000 -0400
+++ xorg-server/GL/glx/glxdri.c	2006-09-28 21:43:26.000000000 -0400
@@ -63,27 +63,30 @@
 #define STRINGIFY(macro_or_string)	STRINGIFY_ARG (macro_or_string)
 #define	STRINGIFY_ARG(contents)	#contents
 
-typedef struct __GLXDRIscreen      __GLXDRIscreen;
-typedef struct __GLXDRIcontext         __GLXDRIcontext;
+typedef struct __GLXDRIscreen   __GLXDRIscreen;
+typedef struct __GLXDRIcontext  __GLXDRIcontext;
 typedef struct __GLXDRIdrawable __GLXDRIdrawable;
 
 struct __GLXDRIscreen {
-    __GLXscreen		 base;
+    __GLXscreen	     base;
 
-    __DRIscreen			 driScreen;
-    void			*driver;
+    xf86EnterVTProc *enterVT;
+    xf86LeaveVTProc *leaveVT;
+
+    __DRIscreen	     driScreen;
+    void	    *driver;
 };
 
 struct __GLXDRIcontext {
-    __GLXcontext		 base;
+    __GLXcontext base;
 
-    __DRIcontext		 driContext;
+    __DRIcontext driContext;
 };
 
 struct __GLXDRIdrawable {
-    __GLXdrawable	 base;
+    __GLXdrawable  base;
 
-    __DRIdrawable		*driDrawable;
+    __DRIdrawable *driDrawable;
 };
 
 /* History:
@@ -556,8 +559,7 @@
 
 static __DRIscreen *findScreen(__DRInativeDisplay *dpy, int scrn)
 {
-    __GLXDRIscreen *screen =
-	(__GLXDRIscreen *) __glXgetActiveScreen(scrn);
+    __GLXDRIscreen *screen = (__GLXDRIscreen *) __glXgetActiveScreen(scrn);
 
     return &screen->driScreen;
 }
@@ -751,6 +753,30 @@
 
 static const char dri_driver_path[] = DRI_DRIVER_PATH;
 
+static Bool
+glxDRIEnterVT (int index, int flags)
+{
+    __GLXDRIscreen *screen = (__GLXDRIscreen *) __glXgetActiveScreen(index);
+
+    LogMessage(X_INFO, "AIGLX: Resuming AIGLX clients after VT switch\n");
+
+    glxResumeClients();
+
+    return (*screen->enterVT) (index, flags);
+}
+
+static void
+glxDRILeaveVT (int index, int flags)
+{
+    __GLXDRIscreen *screen = (__GLXDRIscreen *) __glXgetActiveScreen(index);
+
+    LogMessage(X_INFO, "AIGLX: Suspending AIGLX clients for VT switch\n");
+
+    glxSuspendClients();
+
+    return (*screen->leaveVT) (index, flags);
+}
+
 static __GLXscreen *
 __glXDRIscreenProbe(ScreenPtr pScreen)
 {
@@ -775,6 +801,7 @@
     void *dev_priv = NULL;
     char filename[128];
     Bool isCapable;
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
 
     if (!xf86LoaderCheckSymbol("DRIQueryDirectRenderingCapable")) {
 	LogMessage(X_ERROR, "AIGLX: DRI module not loaded\n");
@@ -944,6 +971,11 @@
 
     __glXsetEnterLeaveServerFuncs(__glXDRIenterServer, __glXDRIleaveServer);
 
+    screen->enterVT = pScrn->EnterVT;
+    pScrn->EnterVT = glxDRIEnterVT; 
+    screen->leaveVT = pScrn->LeaveVT;
+    pScrn->LeaveVT = glxDRILeaveVT;
+
     LogMessage(X_INFO,
 	       "AIGLX: Loaded and initialized %s\n", filename);
 
Index: xorg-server/GL/glx/glxext.c
===================================================================
--- xorg-server.orig/GL/glx/glxext.c	2006-09-28 21:42:10.000000000 -0400
+++ xorg-server/GL/glx/glxext.c	2006-09-28 21:43:26.000000000 -0400
@@ -207,13 +207,11 @@
      * __glXDispatch() or as a callback from the resource manager.  In
      * the latter case we need to lift the DRI lock manually. */
 
-    if (!inDispatch)
-      __glXleaveServer();
+    __glXleaveServer();
 
     cx->destroy(cx);
 
-    if (!inDispatch)
-      __glXenterServer();
+    __glXenterServer();
 
     return GL_TRUE;
 }
@@ -312,7 +310,7 @@
     /*
     ** Initialize table of client state.  There is never a client 0.
     */
-    for (i=1; i <= MAXCLIENTS; i++) {
+    for (i = 1; i <= MAXCLIENTS; i++) {
 	__glXClients[i] = 0;
     }
 
@@ -383,11 +381,36 @@
 
 /************************************************************************/
 
-/*
-** Top level dispatcher; all commands are executed from here down.
-*/
+static int glxServerLeaveCount;
+static int glxBlockClients;
+
+void glxSuspendClients(void)
+{
+    int i;
+
+    for (i = 1; i <= MAXCLIENTS; i++) {
+	if (__glXClients[i] == NULL || !__glXClients[i]->inUse)
+	    continue;
 
-/* I cried when I wrote this.  Damn you XAA! */
+	IgnoreClient(__glXClients[i]->client);
+    }
+
+    glxBlockClients = TRUE;
+}
+
+void glxResumeClients(void)
+{
+    int i;
+
+    glxBlockClients = FALSE;
+
+    for (i = 1; i <= MAXCLIENTS; i++) {
+	if (__glXClients[i] == NULL || !__glXClients[i]->inUse)
+	    continue;
+
+	AttendClient(__glXClients[i]->client);
+    }
+}
 
 static void
 __glXnopEnterServer(void)
@@ -412,14 +435,19 @@
 
 void __glXenterServer(void)
 {
-  (*__glXenterServerFunc)();
+  glxServerLeaveCount--;
+
+  if (glxServerLeaveCount == 0)
+    (*__glXenterServerFunc)();
 }
 
 void __glXleaveServer(void)
 {
-  (*__glXleaveServerFunc)();
-}
+  if (glxServerLeaveCount == 0)
+    (*__glXleaveServerFunc)();
 
+  glxServerLeaveCount++;
+}
 
 /*
 ** Top level dispatcher; all commands are executed from here down.
@@ -472,6 +500,15 @@
 	return __glXBadLargeRequest;
     }
 
+    /* If we're currently blocking GLX clients, just put this guy to
+     * sleep, reset the request and return. */
+    if (glxBlockClients) {
+	ResetCurrentRequest(client);
+	client->sequence--;
+	IgnoreClient(client);
+	return(client->noClientException);
+    }
+
     /*
     ** Use the opcode to index into the procedure table.
     */
@@ -482,12 +519,8 @@
 
     __glXleaveServer();
 
-    inDispatch = True;
-
     retval = proc(cl, (GLbyte *) stuff);
 
-    inDispatch = False;
-
     __glXenterServer();
 
     return retval;
Index: xorg-server/GL/glx/glxserver.h
===================================================================
--- xorg-server.orig/GL/glx/glxserver.h	2006-09-18 17:27:44.000000000 -0400
+++ xorg-server/GL/glx/glxserver.h	2006-09-28 21:43:26.000000000 -0400
@@ -136,6 +136,9 @@
 void __glXenterServer(void);
 void __glXleaveServer(void);
 
+void glxSuspendClients(void);
+void glxResumeClients(void);
+
 /*
 ** State kept per client.
 */
