Index: xorg-server/include/protocol-versions.h
===================================================================
--- xorg-server.orig/include/protocol-versions.h	2012-02-24 21:04:26.323090099 +1100
+++ xorg-server/include/protocol-versions.h	2012-02-27 15:26:08.854514086 +1100
@@ -122,7 +122,7 @@
 #define SERVER_XF86VIDMODE_MINOR_VERSION	2
 
 /* Fixes */
-#define SERVER_XFIXES_MAJOR_VERSION		5
+#define SERVER_XFIXES_MAJOR_VERSION		6
 #define SERVER_XFIXES_MINOR_VERSION		0
 
 /* X Input */
Index: xorg-server/xfixes/cursor.c
===================================================================
--- xorg-server.orig/xfixes/cursor.c	2012-02-24 21:04:26.339090100 +1100
+++ xorg-server/xfixes/cursor.c	2012-02-27 15:26:08.854514086 +1100
@@ -61,6 +61,7 @@
 static RESTYPE		CursorHideCountType;
 static RESTYPE		CursorWindowType;
 RESTYPE			PointerBarrierType;
+static RESTYPE		PointerBarrierClientType;
 static CursorPtr	CursorCurrent[MAXDEVICES];
 
 static DevPrivateKeyRec CursorScreenPrivateKeyRec;
@@ -119,6 +120,11 @@
     struct list entry;
 };
 
+/**
+ * Pick up unclamped (x,y) coordinates from dix/getevents
+ */
+extern int unclamped_prex, unclamped_prey;
+
 /*
  * Wrap DisplayCursor to catch cursor change events
  */
@@ -129,6 +135,7 @@
     ConstrainCursorHarderProcPtr ConstrainCursorHarder;
     CursorHideCountPtr          pCursorHideCounts;
     struct list                 barriers;
+    struct list                 barrierClients;
 } CursorScreenRec, *CursorScreenPtr;
 
 #define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
@@ -1232,18 +1239,90 @@
 }
 
 static void
+SendBarrierEvent(CursorScreenPtr cs, struct PointerBarrier *barrier,
+		 int x, int y, int velocity, Bool threshold_exceeded)
+{
+    PointerBarrierEventClientPtr client;
+    list_for_each_entry(client, &cs->barrierClients, entry) {
+	xXFixesBarrierNotifyEvent	ev;
+	ev.type = XFixesEventBase + XFixesBarrierNotify;
+	ev.subtype = threshold_exceeded ? XFixesBarrierThresholdExceededNotify :
+					  XFixesBarrierHitNotify;
+	ev.event_id = barrier->barrierEventID;
+	ev.barrier = barrier->barrier;
+	ev.x = x;
+	ev.y = y;
+	ev.velocity = velocity;
+	ev.timestamp = currentTime.milliseconds;
+
+	if (client->client->swapped) {
+	    int n;
+
+	    swapl(&ev.event_id, n);
+	    swapl(&ev.barrier, n);
+	    swaps(&ev.x, n);
+	    swaps(&ev.y, n);
+	    swapl(&ev.velocity, n);
+	    swapl(&ev.timestamp, n);
+	}
+	
+	WriteEventsToClient (client->client, 1, (xEvent *) &ev);
+    }
+}
+
+static void
+barrier_calculate_velocity_components (int x1, int y1, int x2, int y2,
+				       int *vel_x, int *vel_y)
+{
+    static CARD32 last_timestamp = 0;
+    CARD32 timestamp = GetTimeInMillis();
+    int dx, dy;
+    int dt = timestamp - last_timestamp;
+
+    if (last_timestamp == 0) {
+	/* Not much we can do for the first event */
+	*vel_x = 0;
+	*vel_y = 0;
+	last_timestamp = timestamp;
+	return;
+    }
+
+    /* Lets not divide by zero if we can avoid it */
+    dt = dt > 0 ? dt : 1;
+
+    dx = x2 - x1;
+    dy = y2 - y1;
+
+    *vel_x = abs(dx) * 1000.0 / dt;
+    *vel_y = abs(dy) * 1000.0 / dt;
+
+    last_timestamp = timestamp;  
+}
+
+static void
 CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
 {
     CursorScreenPtr cs = GetCursorScreen(screen);
 
     if (!list_is_empty(&cs->barriers) && !IsFloating(dev) && mode == Relative) {
 	int ox, oy;
+	int vel_x, vel_y;
 	int dir;
 	struct PointerBarrier *nearest = NULL;
+	PointerBarrierClientPtr c;
 
 	/* where are we coming from */
 	miPointerGetPosition(dev, &ox, &oy);
 
+	/* Use the unclamped values, if available.  If not, *x, *y
+	 * will have to do.
+	 * NOTE: We should never get here with unclamped values unset.
+	 */
+	if (unclamped_prex == -1 || unclamped_prey == -1) {
+	    unclamped_prex = *x;
+	    unclamped_prey = *y;
+	}
+
 	/* How this works:
 	 * Given the origin and the movement vector, get the nearest barrier
 	 * to the origin that is blocking the movement.
@@ -1251,12 +1330,28 @@
 	 * Then, check from the clamped intersection to the original
 	 * destination, again finding the nearest barrier and clamping.
 	 */
-	dir = barrier_get_direction(ox, oy, *x, *y);
+	dir = barrier_get_direction(ox, oy, unclamped_prex, unclamped_prey);
+	barrier_calculate_velocity_components(ox, oy, unclamped_prex, unclamped_prey, &vel_x, &vel_y);
 
-	nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+	nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
 	if (nearest) {
-	    barrier_clamp_to_barrier(nearest, dir, x, y);
+	    int velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+	    Bool threshold_exceeded = (nearest->velocity == 0) ||
+				      (velocity > nearest->velocity);
+
+	    if (!nearest->lastHit) {
+		/* This is the start of a new barrier event */
+		nearest->barrierEventID++;
+	    }
+
+	    if ((!threshold_exceeded || nearest->lastHit) &&
+		(nearest->barrierEventID != nearest->releaseEventID)) {
+		barrier_clamp_to_barrier(nearest, dir, x, y);
+		nearest->hit = TRUE;
+	    }
 
+	    SendBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
+		
 	    if (barrier_is_vertical(nearest)) {
 		dir &= ~(BarrierNegativeX | BarrierPositiveX);
 		ox = *x;
@@ -1265,11 +1360,31 @@
 		oy = *y;
 	    }
 
-	    nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+	    nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
 	    if (nearest) {
-		barrier_clamp_to_barrier(nearest, dir, x, y);
+		velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+		threshold_exceeded = (nearest->velocity == 0) ||
+				     (velocity > nearest->velocity);
+
+		if (!nearest->lastHit) {
+		    /* This is the start of a new barrier event */
+		    nearest->barrierEventID++;
+		}
+
+		if ((!threshold_exceeded || nearest->lastHit) &&
+		    (nearest->barrierEventID != nearest->releaseEventID)) {
+		    barrier_clamp_to_barrier(nearest, dir, x, y);
+		    nearest->hit = TRUE;
+		}
+
+		SendBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
 	    }
 	}
+
+	list_for_each_entry(c, &cs->barriers, entry) {
+	    c->barrier.lastHit = c->barrier.hit;
+	    c->barrier.hit = FALSE;
+	}
     }
 
     if (cs->ConstrainCursorHarder) {
@@ -1288,11 +1403,41 @@
 
     if (ret) {
 	ret->screen = screen;
+	ret->barrier.barrier = stuff->barrier;
+	ret->barrier.x1 = min(stuff->x1, stuff->x2);
+	ret->barrier.x2 = max(stuff->x1, stuff->x2);
+	ret->barrier.y1 = min(stuff->y1, stuff->y2);
+	ret->barrier.y2 = max(stuff->y1, stuff->y2);
+	ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = 0;
+	ret->barrier.barrierEventID = 0;
+	if (barrier_is_horizontal(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
+	if (barrier_is_vertical(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
+	list_add(&ret->entry, &cs->barriers);
+    }
+
+    return ret;
+}
+
+static struct PointerBarrierClient *
+CreatePointerBarrierVelocityClient(ScreenPtr screen, ClientPtr client,
+			   xXFixesCreatePointerBarrierVelocityReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierClient *ret = malloc(sizeof(*ret));
+
+    if (ret) {
+	ret->screen = screen;
+	ret->barrier.barrier = stuff->barrier;
 	ret->barrier.x1 = min(stuff->x1, stuff->x2);
 	ret->barrier.x2 = max(stuff->x1, stuff->x2);
 	ret->barrier.y1 = min(stuff->y1, stuff->y2);
 	ret->barrier.y2 = max(stuff->y1, stuff->y2);
 	ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = stuff->velocity;
+	ret->barrier.barrierEventID = 0;
 	if (barrier_is_horizontal(&ret->barrier))
 	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
 	if (barrier_is_vertical(&ret->barrier))
@@ -1365,6 +1510,69 @@
     return ProcXFixesVector[stuff->xfixesReqType](client);
 }
 
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierClient *barrier;
+    struct PointerBarrier b;
+    REQUEST (xXFixesCreatePointerBarrierVelocityReq);
+
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierVelocityReq);
+    LEGAL_NEW_RESOURCE(stuff->barrier, client);
+
+    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    /* This sure does need fixing. */
+    if (stuff->num_devices)
+	return BadImplementation;
+
+    b.x1 = stuff->x1;
+    b.x2 = stuff->x2;
+    b.y1 = stuff->y1;
+    b.y2 = stuff->y2;
+
+    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
+	return BadValue;
+
+    /* no 0-sized barriers */
+    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
+	return BadValue;
+
+    if (!(barrier = CreatePointerBarrierVelocityClient(pWin->drawable.pScreen,
+						       client, stuff)))
+	return BadAlloc;
+
+    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
+	return BadAlloc;
+
+    return Success;
+}
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesCreatePointerBarrierVelocityReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
+    swapl(&stuff->barrier, n);
+    swapl(&stuff->window, n);
+    swaps(&stuff->x1, n);
+    swaps(&stuff->y1, n);
+    swaps(&stuff->x2, n);
+    swaps(&stuff->y2, n);
+    swapl(&stuff->directions, n);
+    swapl(&stuff->velocity, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 static int
 CursorFreeBarrier(void *data, XID id)
 {
@@ -1421,6 +1629,118 @@
     return ProcXFixesVector[stuff->xfixesReqType](client);
 }
 
+static int
+CursorFreeBarrierClient(void *data, XID id)
+{
+    PointerBarrierEventClientPtr client = data, c;
+    ScreenPtr screen = client->screen;
+    CursorScreenPtr cs = GetCursorScreen(screen);
+
+    /* find and unlink from the screen private */
+    list_for_each_entry(c, &cs->barrierClients, entry) {
+	if (c == client) {
+	    list_del(&c->entry);
+	    break;
+	}
+    }
+
+    free(client);
+    return Success;
+}
+
+static struct PointerBarrierEventClient *
+CreatePointerBarrierEventClient(ScreenPtr screen, ClientPtr client,
+				   xXFixesSelectBarrierInputReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierEventClient *ret = malloc(sizeof(*ret));
+
+    if (ret) {
+	ret->screen = screen;
+	ret->client = client;
+	ret->eventMask = stuff->eventMask;
+	ret->window = stuff->window;
+	ret->resource = FakeClientID (client->index);      
+      list_add(&ret->entry, &cs->barrierClients);
+    }
+
+    return ret;
+}
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierEventClient *eventClient;
+    REQUEST (xXFixesSelectBarrierInputReq);
+
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+
+    err = dixLookupWindow(&pWin	, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    if (!(eventClient = CreatePointerBarrierEventClient(pWin->drawable.pScreen,
+							client,
+							stuff)))
+      return BadAlloc;
+
+    if (!AddResource (eventClient->resource, PointerBarrierClientType, eventClient))
+      return BadAlloc;
+    
+    return Success;
+}
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesSelectBarrierInputReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+    swapl(&stuff->window, n);
+    swapl(&stuff->eventMask, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    int err;
+    struct PointerBarrier *barrier;
+    REQUEST (xXFixesBarrierReleasePointerReq);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+
+    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
+				  PointerBarrierType, client,
+				  DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->barrier;
+	return err;
+    }
+
+    barrier->releaseEventID = stuff->event_id;
+    
+    return Success;
+}
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesBarrierReleasePointerReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+    swapl(&stuff->barrier, n);
+    swapl(&stuff->event_id, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 Bool
 XFixesCursorInit (void)
 {
@@ -1441,6 +1761,7 @@
 	if (!cs)
 	    return FALSE;
 	list_init(&cs->barriers);
+	list_init(&cs->barrierClients);
 	Wrap (cs, pScreen, CloseScreen, CursorCloseScreen);
 	Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
 	Wrap (cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
@@ -1455,8 +1776,10 @@
 					     "XFixesCursorWindow");
     PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
 					      "XFixesPointerBarrier");
+    PointerBarrierClientType = CreateNewResourceType(CursorFreeBarrierClient,
+						     "XFixesPointerBarrierClient");
 
     return CursorClientType && CursorHideCountType && CursorWindowType &&
-	   PointerBarrierType;
+	   PointerBarrierType && PointerBarrierClientType;
 }
 
Index: xorg-server/xfixes/xfixes.c
===================================================================
--- xorg-server.orig/xfixes/xfixes.c	2012-02-24 21:04:26.347090100 +1100
+++ xorg-server/xfixes/xfixes.c	2012-02-27 15:26:08.854514086 +1100
@@ -100,6 +100,7 @@
     X_XFixesExpandRegion,	    /* Version 3 */
     X_XFixesShowCursor,		    /* Version 4 */
     X_XFixesDestroyPointerBarrier,  /* Version 5 */
+    X_XFixesBarrierReleasePointer, /* Version 6 */
 };
 
 #define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
@@ -143,6 +144,10 @@
 /*************** Version 5 ****************/
     ProcXFixesCreatePointerBarrier,
     ProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+    ProcXFixesCreatePointerBarrierVelocity,
+    ProcXFixesSelectBarrierInput,
+    ProcXFixesBarrierReleasePointer,
 };
 
 static int
@@ -209,6 +214,10 @@
 /*************** Version 5 ****************/
     SProcXFixesCreatePointerBarrier,
     SProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+    SProcXFixesCreatePointerBarrierVelocity,
+    SProcXFixesSelectBarrierInput,
+    SProcXFixesBarrierReleasePointer,
 };
 
 static int
Index: xorg-server/xfixes/xfixes.h
===================================================================
--- xorg-server.orig/xfixes/xfixes.h	2012-02-24 21:04:26.355090100 +1100
+++ xorg-server/xfixes/xfixes.h	2012-02-27 15:26:08.854514086 +1100
@@ -28,6 +28,7 @@
 #define _XFIXES_H_
 
 #include "resource.h"
+#include "list.h"
 
 extern _X_EXPORT RESTYPE RegionResType;
 extern _X_EXPORT RESTYPE PointerBarrierType;
@@ -52,9 +53,27 @@
 extern _X_EXPORT RegionPtr
 XFixesRegionCopy (RegionPtr pRegion);
 
+typedef struct PointerBarrierEventClient *PointerBarrierEventClientPtr;
+
+struct PointerBarrierEventClient {
+    ScreenPtr screen;
+    ClientPtr client;
+    CARD32    eventMask;
+    XID window;
+    XID resource;
+    struct list entry;
+};
+
+  
+
 struct PointerBarrier {
+    XID    barrier;
     CARD16 x1, x2, y1, y2;
     CARD32 directions;
+    CARD32 velocity;
+    CARD32 barrierEventID;
+    CARD32 releaseEventID;
+    Bool   hit, lastHit;
 };
 
 
Index: xorg-server/xfixes/xfixesint.h
===================================================================
--- xorg-server.orig/xfixes/xfixesint.h	2012-02-24 21:04:26.363090101 +1100
+++ xorg-server/xfixes/xfixesint.h	2012-02-27 15:26:08.854514086 +1100
@@ -59,6 +59,7 @@
 #include "windowstr.h"
 #include "selection.h"
 #include "xfixes.h"
+#include "list.h"
 
 extern int		XFixesEventBase;
 
@@ -293,6 +294,26 @@
 int
 SProcXFixesDestroyPointerBarrier (ClientPtr client);
 
+/* Version 6 */
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client);
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client);
+
 /* Xinerama */
 extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);
 void PanoramiXFixesInit (void);
Index: xorg-server/dix/getevents.c
===================================================================
--- xorg-server.orig/dix/getevents.c	2012-02-24 21:04:26.371090101 +1100
+++ xorg-server/dix/getevents.c	2012-02-27 16:53:20.102502427 +1100
@@ -79,6 +79,12 @@
 InternalEvent* InputEventList = NULL;
 
 /**
+ * xfixes/cursor.c wants the unclamped (x,y) values for velocity
+ * calculation.  Export them here.
+ */
+int unclamped_prex = -1, unclamped_prey = -1;
+
+/**
  * Pick some arbitrary size for Xi motion history.
  */
 int
@@ -903,7 +909,15 @@
     /* miPointerSetPosition takes care of crossing screens for us, as well as
      * clipping to the current screen. Coordinates returned are in desktop
      * coord system */
+    /** 
+     * Hack to pass the unclipped values through to the pointer barrier code.
+     * Required (for now) to calculate the velocity.
+     */
+    unclamped_prex = (int)floor(*screenx) - scr->x;
+    unclamped_prey = (int)floor(*screeny) - scr->y;
     scr = miPointerSetPosition(dev, mode, screenx, screeny);
+    unclamped_prex = -1;
+    unclamped_prey = -1;
 
     /* If we were constrained, rescale x/y from the screen coordinates so
      * the device valuators reflect the correct position. For screen
Index: xorg-server/test/gtest/xfixes_barriers.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/test/gtest/xfixes_barriers.cpp	2012-02-27 16:28:27.474505754 +1100
@@ -0,0 +1,179 @@
+/*
+
+Copyright (c) 2012, Canonical Ltd
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice (including the next
+paragraph) shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
+*/
+
+#include <iostream>
+#include <gtest/gtest.h>
+#include <xorg/gtest/test.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/XTest.h>
+#include <X11/extensions/Xfixes.h>
+
+class BarrierTest : public xorg::testing::Test {
+    public:
+    ::Display *dpy;
+    static XErrorEvent *lastError;
+
+    void AssertPointerPosition (int asserted_x, int asserted_y)
+    {
+        int x, y, unused_int;
+        unsigned int unused_uint;
+        Window unused_win;
+        
+        XQueryPointer (Display (), DefaultRootWindow (Display ()),
+                       &unused_win, &unused_win, &x, &y,
+                       &unused_int, &unused_int, &unused_uint);
+
+        ASSERT_EQ (asserted_x, x) << "Cursor X coordinate incorrect\n";
+        ASSERT_EQ (asserted_y, y) << "Cursor Y coordinate incorrect\n";
+    }
+
+    protected:
+    virtual void SetUp ()
+    {
+        ASSERT_NO_FATAL_FAILURE (xorg::testing::Test::SetUp());
+
+        dpy = Display ();
+        XSynchronize (Display(), true);
+        int major = 2, minor = 2;
+        ASSERT_TRUE (XTestQueryExtension (dpy,
+                                          &xtest_eventbase, &xtest_errorbase,
+                                          &major, &minor));
+        ASSERT_EQ (2, major);
+        ASSERT_TRUE (minor >= 2);
+
+        major = 6;
+        minor = 0;
+        XFixesQueryVersion (dpy, &major, &minor);
+        ASSERT_EQ (6, major);
+        ASSERT_TRUE (minor >= 0);
+
+        ASSERT_TRUE (XFixesQueryExtension (dpy,
+                                           &fixes_eventbase, &fixes_errorbase));
+
+        lastError = new XErrorEvent;
+        XSetErrorHandler (ErrorHandler);
+    }
+
+    private:
+    static int ErrorHandler (::Display *dpy, XErrorEvent *error)
+    {
+        memcpy (lastError, error, sizeof (*lastError));
+        return 0;
+    } 
+    
+    int xtest_eventbase;
+    int xtest_errorbase;
+    int fixes_eventbase;
+    int fixes_errorbase;
+};
+
+XErrorEvent *BarrierTest::lastError = NULL;
+
+TEST_F (BarrierTest, CreateVerticalBarrierSucceeds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 0,
+                                          100, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateHorizontalBarrierSucceds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 100,
+                                          200, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateNonAxisAlignedBarrierFails)
+{
+    PointerBarrier barrier;
+    
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          0, 0,
+                                          100, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_EQ(BadValue, lastError->error_code);
+}
+ 
+TEST_F (BarrierTest, VerticalBidirectionalBarrierBlocksRelativeMotion)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow (dpy),
+                                          100, 0,
+                                          100, 300,
+                                          0,
+                                          0, NULL);
+    // Absolute event will ignore barrier
+    XTestFakeMotionEvent (dpy, DefaultScreen (dpy),
+                          200, 100,
+                          0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (200, 100));
+
+    // Relative motion should block on barrier
+    XTestFakeRelativeMotionEvent (dpy, -200, 0, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (100, 100));
+}
+
+TEST_F (BarrierTest, VerticalPositiveXBarrierBlocksMotion)
+{
+    PointerBarrier positiveXBarrier;
+    positiveXBarrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow (dpy),
+                                                   100, 0,
+                                                   100, 300,
+                                                   BarrierPositiveX,
+                                                   0, NULL);
+    // Absolute event will ignore barrier
+    XTestFakeMotionEvent (dpy, DefaultScreen (dpy),
+                          200, 100,
+                          0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (200, 100));
+    
+    // Relative motion in -ve X direction should block on barrier
+    XTestFakeRelativeMotionEvent (dpy, -200, 0, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (100, 100));
+
+    // Absolute event will ignore barrier
+    XTestFakeMotionEvent (dpy, DefaultScreen (dpy),
+                          0, 100,
+                          0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (0, 100));
+                          
+    // Relative motion in +ve X direction should ignore barrier
+    XTestFakeRelativeMotionEvent (dpy, 200, 0, 0);
+    
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (200, 100));
+}
Index: xorg-server/configure.ac
===================================================================
--- xorg-server.orig/configure.ac	2012-02-27 15:26:08.834514085 +1100
+++ xorg-server/configure.ac	2012-02-27 16:53:20.142502426 +1100
@@ -2155,6 +2155,25 @@
 
 AC_CONFIG_COMMANDS([sdksyms], [touch hw/xfree86/sdksyms.dep])
 
+AC_PROG_CXX
+
+PKG_CHECK_MODULES(XORG_GTEST, xorg-gtest,
+        [have_xorg_gtest="yes"],
+        [AC_MSG_WARN([xorg-gtest not installed, tests will not be built])])
+AM_CONDITIONAL([HAVE_XORG_GTEST], [test "x$have_xorg_gtest" = xyes])
+AC_SUBST([XORG_GTEST_CFLAGS])
+AC_SUBST([XORG_GTEST_LIBS])
+
+PKG_CHECK_MODULES([XFIXES], xfixes, [have_xfixes="yes"], [have_xfixes="no"])
+AM_CONDITIONAL([HAVE_XFIXES], [test "x$have_xfixes" = xyes])
+AC_SUBST([XFIXES_CFLAGS])
+AC_SUBST([XFIXES_LIBS])
+
+PKG_CHECK_MODULES([XTEST], xtst, [have_xtest="yes"], [have_xtest="no"])
+AM_CONDITIONAL([HAVE_XTEST], [test "x$have_xtest" = xyes])
+AC_SUBST([XTEST_CFLAGS])
+AC_SUBST([XTEST_LIBS])
+
 AC_OUTPUT([
 Makefile
 glx/Makefile
@@ -2254,6 +2273,7 @@
 hw/kdrive/src/Makefile
 test/Makefile
 test/xi2/Makefile
+test/gtest/Makefile
 xserver.ent
 xorg-server.pc
 ])
Index: xorg-server/test/gtest/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/test/gtest/Makefile.am	2012-02-27 15:26:08.858514086 +1100
@@ -0,0 +1,17 @@
+noinst_PROGRAMS = xfixes_barriers
+
+TESTS=xfixes_barriers
+
+xfixes_barriers_CXXFLAGS = $(AM_CXXFLAGS) \
+	$(XORG_GTEST_CFLAGS) \
+	$(XTEST_CFLAGS) \
+	$(XFIXES_CFLAGS)
+
+xfixes_barriers_LDADD = \
+	$(XFIXES_LIBS) \
+	$(XTEST_LIBS) \
+	$(XORG_GTEST_LIBS) \
+	-lgtest -lxorg-gtest_main -lpthread
+
+xfixes_barriers_SOURCES = \
+	xfixes_barriers.cpp
Index: xorg-server/test/Makefile.am
===================================================================
--- xorg-server.orig/test/Makefile.am	2012-02-24 21:04:26.391090102 +1100
+++ xorg-server/test/Makefile.am	2012-02-27 15:26:08.858514086 +1100
@@ -1,5 +1,5 @@
 if ENABLE_UNIT_TESTS
-SUBDIRS= . xi2
+SUBDIRS= . xi2 gtest
 noinst_PROGRAMS = xkb input xtest list misc fixes xfree86 touch
 check_LTLIBRARIES = libxservertest.la
 
